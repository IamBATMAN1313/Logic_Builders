-- =====================================================
-- LogicBuilders E-commerce Database Schema
-- Complete Database Structure with All Dependencies
-- =====================================================

-- Enable UUID extension first
CREATE EXTENSION IF NOT EXISTS "uuid-ossp" WITH SCHEMA public;

-- =====================================================
-- FUNCTIONS & PROCEDURES
-- =====================================================

-- Function: Check cart stock before adding items
CREATE FUNCTION public.check_cart_stock() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
    current_stock INTEGER;
    current_cart_quantity INTEGER;
    total_quantity INTEGER;
BEGIN
    -- Get current stock for the product
    SELECT stock INTO current_stock
    FROM product_attribute
    WHERE product_id = NEW.product_id;
    
    -- Get current quantity in cart for this product and customer
    SELECT COALESCE(SUM(quantity), 0) INTO current_cart_quantity
    FROM cart_item ci
    JOIN cart c ON ci.cart_id = c.id
    WHERE c.customer_id = (
        SELECT customer_id 
        FROM cart 
        WHERE id = NEW.cart_id
    ) AND ci.product_id = NEW.product_id
    AND ci.id != COALESCE(NEW.id, -1); -- Exclude current item in case of update
    
    -- Calculate total quantity if this item is added/updated
    total_quantity := current_cart_quantity + NEW.quantity;
    
    -- Check if total quantity exceeds stock
    IF total_quantity > current_stock THEN
        RAISE EXCEPTION 'Cannot add % items to cart. Only % items available (% already in cart)', 
            NEW.quantity, current_stock, current_cart_quantity;
    END IF;
    
    RETURN NEW;
END;
$$;

-- Function: Check order stock before placing order
CREATE FUNCTION public.check_order_stock() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
    current_stock INTEGER;
BEGIN
    -- Get current stock for the product
    SELECT stock INTO current_stock
    FROM product_attribute
    WHERE product_id = NEW.product_id;
    
    -- Check if quantity exceeds stock
    IF NEW.quantity > current_stock THEN
        RAISE EXCEPTION 'Cannot order % items. Only % items available in stock', 
            NEW.quantity, current_stock;
    END IF;
    
    RETURN NEW;
END;
$$;

-- Function: Handle stock changes when orders are placed/cancelled
CREATE FUNCTION public.handle_order_stock() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
    item RECORD;
BEGIN
    IF TG_OP = 'INSERT' THEN
        -- Order is being placed, decrease stock
        FOR item IN 
            SELECT product_id, quantity 
            FROM order_item 
            WHERE order_id = NEW.id
        LOOP
            UPDATE product_attribute 
            SET stock = stock - item.quantity
            WHERE product_id = item.product_id;
            
            -- Check if stock went negative (shouldn't happen with cart check, but safety)
            UPDATE product_attribute 
            SET stock = 0 
            WHERE product_id = item.product_id AND stock < 0;
        END LOOP;
        
    ELSIF TG_OP = 'UPDATE' THEN
        -- Check if order status changed to cancelled
        IF OLD.status != 'cancelled' AND NEW.status = 'cancelled' THEN
            -- Order is being cancelled, restore stock
            FOR item IN 
                SELECT product_id, quantity 
                FROM order_item 
                WHERE order_id = NEW.id
            LOOP
                UPDATE product_attribute 
                SET stock = stock + item.quantity
                WHERE product_id = item.product_id;
            END LOOP;
        ELSIF OLD.status = 'cancelled' AND NEW.status != 'cancelled' THEN
            -- Order is being uncancelled, decrease stock again
            FOR item IN 
                SELECT product_id, quantity 
                FROM order_item 
                WHERE order_id = NEW.id
            LOOP
                UPDATE product_attribute 
                SET stock = stock - item.quantity
                WHERE product_id = item.product_id;
                
                -- Check if stock went negative
                UPDATE product_attribute 
                SET stock = 0 
                WHERE product_id = item.product_id AND stock < 0;
            END LOOP;
        END IF;
    END IF;
    
    RETURN COALESCE(NEW, OLD);
END;
$$;

-- Function: Notify customers when order status changes
CREATE FUNCTION public.notify_order_status_change() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
  customer_user_id UUID;
BEGIN
  -- Only notify on status changes
  IF OLD.status IS DISTINCT FROM NEW.status THEN
    -- Get customer user_id
    SELECT c.user_id INTO customer_user_id
    FROM customer c
    WHERE c.id = NEW.customer_id;
    
    -- Create notification
    INSERT INTO notification (
      user_id,
      notification_text,
      notification_type,
      category,
      link,
      priority,
      data
    ) VALUES (
      customer_user_id,
      'Your order #' || NEW.id || ' status has been updated to: ' || NEW.status,
      'order_status_update',
      'orders',
      '/account/orders',
      'normal',
      jsonb_build_object(
        'order_id', NEW.id,
        'old_status', OLD.status,
        'new_status', NEW.status
      )
    );
  END IF;
  
  RETURN NEW;
END;
$$;

-- Function: Notify customers when Q&A is answered
CREATE FUNCTION public.notify_qa_answered() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
  customer_user_id UUID;
  question_text TEXT;
  product_name TEXT;
BEGIN
  -- Get customer user_id and question details
  SELECT c.user_id, pqa.question_text, p.name
  INTO customer_user_id, question_text, product_name
  FROM product_qa pqa
  JOIN customer c ON pqa.customer_id = c.id
  JOIN product p ON pqa.product_id = p.id
  WHERE pqa.id = NEW.question_id;

  -- Create notification for customer
  INSERT INTO notification (
    user_id,
    notification_text,
    notification_type,
    category,
    link,
    priority,
    data
  ) VALUES (
    customer_user_id,
    'Your question about "' || product_name || '" has been answered.',
    'qa_answered',
    'support',
    '/product/' || (SELECT product_id FROM product_qa WHERE id = NEW.question_id),
    'normal',
    jsonb_build_object(
      'question_id', NEW.question_id,
      'answer_id', NEW.id,
      'product_name', product_name,
      'is_published', NEW.is_published
    )
  );

  -- Send message if requested
  IF NEW.send_to_customer = TRUE THEN
    INSERT INTO message (
      sender_id,
      receiver_id,
      message_text,
      subject,
      message_type,
      is_system_message
    ) VALUES (
      (SELECT user_id FROM admin_users WHERE admin_id = NEW.admin_id),
      customer_user_id,
      'Your question: "' || LEFT(question_text, 100) || '..." has been answered: ' || NEW.answer_text,
      'Answer to your product question',
      'text',
      TRUE
    );
  END IF;

  -- Update question status
  UPDATE product_qa
  SET status = CASE
    WHEN NEW.is_published THEN 'published'
    ELSE 'answered'
  END,
  updated_at = CURRENT_TIMESTAMP
  WHERE id = NEW.question_id;

  RETURN NEW;
END;
$$;

-- Function: Sync product availability with stock levels
CREATE FUNCTION public.sync_all_product_availability() RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    -- Set availability to false for products with 0 stock
    UPDATE product 
    SET availability = false 
    WHERE id IN (
        SELECT product_id 
        FROM product_attribute 
        WHERE stock = 0
    );
    
    -- Set availability to true for products with positive stock
    UPDATE product 
    SET availability = true 
    WHERE id IN (
        SELECT product_id 
        FROM product_attribute 
        WHERE stock > 0
    );
    
    RAISE NOTICE 'Product availability synced with stock levels';
END;
$$;

-- Function: Update product availability when stock changes
CREATE FUNCTION public.update_product_availability() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    -- When stock goes to 0, set availability to false
    -- When stock goes from 0 to positive, set availability to true
    
    IF TG_OP = 'UPDATE' THEN
        -- Check if stock changed from positive to 0
        IF OLD.stock > 0 AND NEW.stock = 0 THEN
            UPDATE product 
            SET availability = false 
            WHERE id = NEW.product_id;
        END IF;
        
        -- Check if stock changed from 0 to positive
        IF OLD.stock = 0 AND NEW.stock > 0 THEN
            UPDATE product 
            SET availability = true 
            WHERE id = NEW.product_id;
        END IF;
    END IF;
    
    IF TG_OP = 'INSERT' THEN
        -- Set availability based on initial stock
        IF NEW.stock = 0 THEN
            UPDATE product 
            SET availability = false 
            WHERE id = NEW.product_id;
        ELSE
            UPDATE product 
            SET availability = true 
            WHERE id = NEW.product_id;
        END IF;
    END IF;
    
    RETURN COALESCE(NEW, OLD);
END;
$$;

-- Function: Validate rating eligibility
CREATE FUNCTION public.validate_rating_eligibility() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
  -- Check if the order exists and is delivered
  -- Handle both direct products and products from builds
  IF NOT EXISTS (
    -- Check for direct product purchase
    SELECT 1 
    FROM "order" o
    JOIN order_item oi ON o.id = oi.order_id
    JOIN customer c ON o.customer_id = c.id
    WHERE o.id = NEW.order_id 
      AND oi.id = NEW.order_item_id
      AND c.user_id = NEW.user_id
      AND oi.product_id = NEW.product_id
      AND o.status = 'delivered'
    
    UNION
    
    -- Check for product from build purchase
    SELECT 1
    FROM "order" o
    JOIN order_item oi ON o.id = oi.order_id
    JOIN customer c ON o.customer_id = c.id
    JOIN build b ON oi.build_id = b.id
    JOIN build_product bp ON b.id = bp.build_id
    WHERE o.id = NEW.order_id 
      AND oi.id = NEW.order_item_id
      AND c.user_id = NEW.user_id
      AND bp.product_id = NEW.product_id
      AND o.status = 'delivered'
  ) THEN
    RAISE EXCEPTION 'Can only rate products from delivered orders that you have purchased';
  END IF;
  
  RETURN NEW;
END;
$$;

-- Function: Update conversation last message timestamp
CREATE FUNCTION public.update_conversation_last_message() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
  UPDATE conversation 
  SET last_message_at = NEW.sent_at, updated_at = CURRENT_TIMESTAMP
  WHERE id = NEW.conversation_id;
  RETURN NEW;
END;
$$;

-- Function: Generic updated_at timestamp updater
CREATE FUNCTION public.update_updated_at_column() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
  NEW.updated_at = CURRENT_TIMESTAMP;
  RETURN NEW;
END;
$$;

-- Function: Update admin_users updated_at
CREATE FUNCTION public.update_admin_users_updated_at() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
  NEW.updated_at = CURRENT_TIMESTAMP;
  RETURN NEW;
END;
$$;

-- Function: Update access_levels updated_at
CREATE FUNCTION public.update_access_levels_updated_at() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
  NEW.updated_at = CURRENT_TIMESTAMP;
  RETURN NEW;
END;
$$;

-- Function: Update signup requests updated_at
CREATE FUNCTION public.update_signup_requests_updated_at() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
  NEW.updated_at = CURRENT_TIMESTAMP;
  RETURN NEW;
END;
$$;
-- - Updated access control to use role-based permissions instead of hierarchical
-- - Frontend now hides level numbers and shows only role names
-- ============================================================================

-- Enable UUID generation extension
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

-- ============================================================================
-- UTILITY FUNCTIONS
-- ============================================================================

-- Trigger function to auto-update updated_at timestamps
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = CURRENT_TIMESTAMP;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- ============================================================================
-- CORE USER TABLES
-- ============================================================================

-- 1. general_user - Base user table for all platform users
CREATE TABLE general_user (
  id             UUID      PRIMARY KEY DEFAULT uuid_generate_v4(),
  username       VARCHAR(100) UNIQUE NOT NULL,
  email          VARCHAR(100) UNIQUE NOT NULL,
  password_hash  TEXT      NOT NULL,
  contact_no     VARCHAR(20) UNIQUE,
  profile_img    TEXT,
  full_name      VARCHAR(100) NOT NULL,
  gender         VARCHAR(10),
  created_at     TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at     TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
);

CREATE TRIGGER trg_general_user_updated_at
  BEFORE UPDATE ON general_user
  FOR EACH ROW EXECUTE PROCEDURE update_updated_at_column();

-- ============================================================================
-- ACCESS CONTROL SYSTEM
-- ============================================================================
-- 
-- UPDATED ACCESS LEVELS (Cleaned up - removed unused levels 1, 7, 8):
-- Level 0: General Manager - Full system access
-- Level 2: Inventory Manager - Inventory + Dashboard + Settings only  
-- Level 3: Product Manager (renamed from Product Expert) - All except Admin Management
-- Level 4: Order Manager - Orders + Dashboard + Settings only
-- Level 5: Promotion Manager - Promotions + Analytics + Dashboard + Settings
-- Level 6: Analytics Specialist - Analytics + Dashboard + Settings only
--
-- Role-Based Access Rules:
-- - Everyone has access to Dashboard and Settings
-- - Only General Manager can access Admin Management section of Settings
-- - Access levels use specific permission-based rules rather than hierarchical
-- ============================================================================

-- access_levels - Defines numerical access levels and their descriptions
CREATE TABLE access_levels (
  access_level INTEGER PRIMARY KEY,
  access_name VARCHAR(100) NOT NULL UNIQUE,
  description TEXT,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Insert access levels 
INSERT INTO access_levels (access_level, access_name, description) VALUES
(0, 'General Manager', 'Highest level of access - can manage all aspects of the system'),
(2, 'Inventory Manager', 'Can manage inventory and stock levels'),
(3, 'Product Manager', 'Manages product catalog, pricing, and product-related operations. Can access all areas except admin management'),
(4, 'Order Manager', 'Can manage orders and delivery status'),
(5, 'Promotion Manager', 'Can manage promotions and discounts'),
(6, 'Analytics Specialist', 'Can view and analyze system data');

CREATE OR REPLACE FUNCTION update_access_levels_updated_at()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = CURRENT_TIMESTAMP;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_access_levels_updated_at
  BEFORE UPDATE ON access_levels
  FOR EACH ROW EXECUTE PROCEDURE update_access_levels_updated_at();

CREATE INDEX idx_access_levels_name ON access_levels(access_name);

-- ============================================================================
-- ADMIN USERS SYSTEM  
-- ============================================================================

-- admin_users - Admin users with numerical clearance levels
CREATE TABLE admin_users (
  admin_id         SERIAL    PRIMARY KEY,
  employee_id      VARCHAR(10) UNIQUE NOT NULL, -- EMP001, EMP002, etc.
  name             VARCHAR(100) NOT NULL,
  email            VARCHAR(100) UNIQUE,
  password         TEXT      NOT NULL,
  phone            VARCHAR(20),
  department       VARCHAR(100),
  position         VARCHAR(100),
  clearance_level  INTEGER   NOT NULL REFERENCES access_levels(access_level),
  is_employed      BOOLEAN   NOT NULL DEFAULT TRUE,
  created_at       TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at       TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
);

CREATE TRIGGER trg_admin_users_updated_at
  BEFORE UPDATE ON admin_users
  FOR EACH ROW EXECUTE PROCEDURE update_updated_at_column();

CREATE INDEX idx_admin_clearance_level ON admin_users(clearance_level);
CREATE INDEX idx_admin_employee_id ON admin_users(employee_id);
CREATE INDEX idx_admin_email ON admin_users(email);

-- admin_signup_requests - Requests for admin access
CREATE TABLE admin_signup_requests (
  request_id          SERIAL    PRIMARY KEY,
  employee_id         VARCHAR(10) NOT NULL,
  name                VARCHAR(100) NOT NULL,
  email               VARCHAR(100) NOT NULL,
  password            TEXT      NOT NULL,
  department          VARCHAR(100),
  requested_clearance INTEGER   NOT NULL REFERENCES access_levels(access_level),
  assigned_clearance  INTEGER   REFERENCES access_levels(access_level),
  status              VARCHAR(20) DEFAULT 'PENDING' CHECK (status IN ('PENDING', 'APPROVED', 'REJECTED')),
  approved_by         INTEGER   REFERENCES admin_users(admin_id),
  rejection_reason    TEXT,
  created_at          TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_at          TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TRIGGER trg_admin_signup_requests_updated_at
  BEFORE UPDATE ON admin_signup_requests
  FOR EACH ROW EXECUTE PROCEDURE update_updated_at_column();

CREATE INDEX idx_signup_requests_status ON admin_signup_requests(status);
CREATE INDEX idx_signup_requests_employee_id ON admin_signup_requests(employee_id);

-- ============================================================================
-- LEGACY ADMIN TABLE (Replaced by admin_users)
-- ============================================================================

-- 2. admin - Admin users with role-based access control (DEPRECATED - Use admin_users instead)
CREATE TABLE admin (
  id               UUID      PRIMARY KEY DEFAULT uuid_generate_v4(),
  user_id          UUID      NOT NULL REFERENCES general_user(id) ON DELETE CASCADE,
  clearance_level  INTEGER   NOT NULL REFERENCES access_levels(access_level),
  is_employed      BOOLEAN   NOT NULL DEFAULT TRUE,
  hire_date        TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
  created_at       TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at       TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
);

CREATE TRIGGER trg_admin_updated_at
  BEFORE UPDATE ON admin
  FOR EACH ROW EXECUTE PROCEDURE update_updated_at_column();

CREATE INDEX idx_admin_user_id ON admin(user_id);
CREATE INDEX idx_admin_clearance_level_old ON admin(clearance_level);

-- 3. customer - Customer-specific user data
CREATE TABLE customer (
  id          UUID      PRIMARY KEY DEFAULT uuid_generate_v4(),
  user_id     UUID      NOT NULL REFERENCES general_user(id) ON DELETE CASCADE,
  points      INTEGER   NOT NULL DEFAULT 0 CHECK (points >= 0),
  created_at  TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at  TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
);

CREATE TRIGGER trg_customer_updated_at
  BEFORE UPDATE ON customer
  FOR EACH ROW EXECUTE PROCEDURE update_updated_at_column();

CREATE INDEX idx_customer_user_id ON customer(user_id);

-- ============================================================================
-- PRODUCT CATALOG TABLES
-- ============================================================================

-- 4. product_category - Product categorization
CREATE TABLE product_category (
  id           SERIAL    PRIMARY KEY,
  name         VARCHAR(100) UNIQUE NOT NULL,
  description  TEXT,
  image_url    TEXT,
  created_at   TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at   TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
);

CREATE TRIGGER trg_product_category_updated_at
  BEFORE UPDATE ON product_category
  FOR EACH ROW EXECUTE PROCEDURE update_updated_at_column();

-- 5. product - Main product information
CREATE TABLE product (
  id                SERIAL    PRIMARY KEY,
  name              VARCHAR(200) NOT NULL,
  excerpt           TEXT,
  image_url         TEXT,
  price             NUMERIC(10,2) NOT NULL CHECK (price >= 0),
  discount_status   BOOLEAN   NOT NULL DEFAULT FALSE,
  discount_percent  NUMERIC(5,2) NOT NULL DEFAULT 0 CHECK (discount_percent BETWEEN 0 AND 100),
  availability      BOOLEAN   NOT NULL DEFAULT TRUE,
  date_added        DATE      NOT NULL DEFAULT CURRENT_DATE,
  category_id       INTEGER   NOT NULL REFERENCES product_category(id) ON DELETE CASCADE,
  specs             JSONB     DEFAULT '{}'::JSONB,
  created_at        TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at        TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
);

CREATE TRIGGER trg_product_updated_at
  BEFORE UPDATE ON product
  FOR EACH ROW EXECUTE PROCEDURE update_updated_at_column();

CREATE INDEX idx_product_category_id ON product(category_id);
CREATE INDEX idx_product_specs_gin ON product USING GIN (specs);
CREATE INDEX idx_product_availability ON product(availability);
CREATE INDEX idx_product_price ON product(price);

-- 6. product_attribute - Product inventory and cost management
CREATE TABLE product_attribute (
  id           UUID      PRIMARY KEY DEFAULT uuid_generate_v4(),
  product_id   INTEGER   NOT NULL REFERENCES product(id) ON DELETE CASCADE,
  cost         NUMERIC(10,2) NOT NULL CHECK (cost >= 0),
  units_sold   INTEGER   NOT NULL DEFAULT 0 CHECK (units_sold >= 0),
  stock        INTEGER   NOT NULL DEFAULT 0 CHECK (stock >= 0),
  created_at   TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at   TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
);

CREATE TRIGGER trg_product_attribute_updated_at
  BEFORE UPDATE ON product_attribute
  FOR EACH ROW EXECUTE PROCEDURE update_updated_at_column();

CREATE INDEX idx_product_attribute_product_id ON product_attribute(product_id);
CREATE INDEX idx_product_attribute_stock ON product_attribute(stock);

-- ============================================================================
-- BUILD SYSTEM TABLES (PC Building Feature)
-- ============================================================================

-- 7. template - Predefined PC build templates
CREATE TABLE template (
  id          SERIAL    PRIMARY KEY,
  name        VARCHAR(100) NOT NULL,
  description TEXT,
  created_at  TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at  TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
);

CREATE TRIGGER trg_template_updated_at
  BEFORE UPDATE ON template
  FOR EACH ROW EXECUTE PROCEDURE update_updated_at_column();

-- 8. template_product - Products included in templates
CREATE TABLE template_product (
  id           SERIAL  PRIMARY KEY,
  template_id  INTEGER NOT NULL REFERENCES template(id) ON DELETE CASCADE,
  product_id   INTEGER NOT NULL REFERENCES product(id) ON DELETE CASCADE,
  quantity     INTEGER NOT NULL CHECK (quantity > 0),
  created_at   TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
  UNIQUE(template_id, product_id)
);

CREATE INDEX idx_template_product_template_id ON template_product(template_id);
CREATE INDEX idx_template_product_product_id ON template_product(product_id);

-- 9. build - Customer custom builds
CREATE TABLE build (
  id            SERIAL    PRIMARY KEY,
  customer_id   UUID      NOT NULL REFERENCES customer(id) ON DELETE CASCADE,
  template_id   INTEGER   REFERENCES template(id) ON DELETE SET NULL,
  name          VARCHAR(200),
  created_at    TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at    TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
);

CREATE TRIGGER trg_build_updated_at
  BEFORE UPDATE ON build
  FOR EACH ROW EXECUTE PROCEDURE update_updated_at_column();

CREATE INDEX idx_build_customer_id ON build(customer_id);
CREATE INDEX idx_build_template_id ON build(template_id);

-- 10. build_product - Products in customer builds
CREATE TABLE build_product (
  id         SERIAL  PRIMARY KEY,
  build_id   INTEGER NOT NULL REFERENCES build(id) ON DELETE CASCADE,
  product_id INTEGER NOT NULL REFERENCES product(id) ON DELETE CASCADE,
  quantity   INTEGER NOT NULL CHECK (quantity > 0),
  created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
  UNIQUE(build_id, product_id)
);

CREATE INDEX idx_build_product_build_id ON build_product(build_id);
CREATE INDEX idx_build_product_product_id ON build_product(product_id);

-- ============================================================================
-- SHOPPING CART TABLES
-- ============================================================================

-- 11. cart - Customer shopping carts
CREATE TABLE cart (
  id          SERIAL    PRIMARY KEY,
  customer_id UUID      NOT NULL REFERENCES customer(id) ON DELETE CASCADE,
  created_at  TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at  TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
  UNIQUE(customer_id)
);

CREATE TRIGGER trg_cart_updated_at
  BEFORE UPDATE ON cart
  FOR EACH ROW EXECUTE PROCEDURE update_updated_at_column();

CREATE INDEX idx_cart_customer_id ON cart(customer_id);

-- 12. cart_item - Items in shopping carts
CREATE TABLE cart_item (
  id           SERIAL    PRIMARY KEY,
  cart_id      INTEGER   NOT NULL REFERENCES cart(id) ON DELETE CASCADE,
  product_id   INTEGER   REFERENCES product(id) ON DELETE CASCADE,
  build_id     INTEGER   REFERENCES build(id) ON DELETE CASCADE,
  quantity     INTEGER   NOT NULL CHECK (quantity > 0),
  unit_price   NUMERIC(10,2) NOT NULL CHECK (unit_price >= 0),
  created_at   TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
  CHECK (
    (product_id IS NOT NULL AND build_id IS NULL)
    OR
    (product_id IS NULL AND build_id IS NOT NULL)
  )
);

CREATE INDEX idx_cart_item_cart_id ON cart_item(cart_id);
CREATE INDEX idx_cart_item_product_id ON cart_item(product_id);
CREATE INDEX idx_cart_item_build_id ON cart_item(build_id);

-- ============================================================================
-- SHIPPING & ORDERS TABLES
-- ============================================================================

-- 13. shipping_address - Customer shipping addresses
CREATE TABLE shipping_address (
  id           SERIAL    PRIMARY KEY,
  customer_id  UUID      REFERENCES customer(id) ON DELETE CASCADE,
  address      TEXT      NOT NULL,
  city         VARCHAR(100) NOT NULL,
  zip_code     VARCHAR(20) NOT NULL,
  country      VARCHAR(100) NOT NULL,
  is_default   BOOLEAN   NOT NULL DEFAULT FALSE,
  created_at   TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at   TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
);

CREATE TRIGGER trg_shipping_address_updated_at
  BEFORE UPDATE ON shipping_address
  FOR EACH ROW EXECUTE PROCEDURE update_updated_at_column();

CREATE INDEX idx_shipping_address_customer_id ON shipping_address(customer_id);

-- 14. promo - Promotional offers and discounts
CREATE TABLE promo (
  id               SERIAL    PRIMARY KEY,
  name             VARCHAR(100) UNIQUE NOT NULL,
  code             VARCHAR(50) UNIQUE NOT NULL,
  discount_percent NUMERIC(5,2) NOT NULL CHECK (discount_percent BETWEEN 0 AND 100),
  status           VARCHAR(20) NOT NULL CHECK (status IN ('active', 'inactive', 'expired')),
  start_date       DATE      NOT NULL DEFAULT CURRENT_DATE,
  end_date         DATE      NOT NULL,
  usage_limit      INTEGER   CHECK (usage_limit > 0),
  usage_count      INTEGER   NOT NULL DEFAULT 0,
  created_at       TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at       TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
);

CREATE TRIGGER trg_promo_updated_at
  BEFORE UPDATE ON promo
  FOR EACH ROW EXECUTE PROCEDURE update_updated_at_column();

CREATE INDEX idx_promo_code ON promo(code);
CREATE INDEX idx_promo_status ON promo(status);
CREATE INDEX idx_promo_dates ON promo(start_date, end_date);

-- 15. "order" - Customer orders
CREATE TABLE "order" (
  id                   SERIAL    PRIMARY KEY,
  customer_id          UUID      NOT NULL REFERENCES customer(id) ON DELETE CASCADE,
  promo_id             INTEGER   REFERENCES promo(id) ON DELETE SET NULL,
  order_date           DATE      NOT NULL DEFAULT CURRENT_DATE,
  payment_status       BOOLEAN   NOT NULL DEFAULT FALSE,
  payment_method       VARCHAR(50) NOT NULL,
  status               VARCHAR(30) NOT NULL DEFAULT 'pending' CHECK (status IN (
    'pending', 'confirmed', 'processing', 'shipped', 'delivered', 'cancelled'
  )),
  delivery_charge      NUMERIC(10,2) NOT NULL CHECK (delivery_charge >= 0),
  discount_amount      NUMERIC(10,2) NOT NULL DEFAULT 0 CHECK (discount_amount >= 0),
  total_price          NUMERIC(10,2) NOT NULL CHECK (total_price >= 0),
  transaction_id       VARCHAR(100),
  shipping_address_id  INTEGER   NOT NULL REFERENCES shipping_address(id) ON DELETE CASCADE,
  estimated_delivery   DATE,
  created_at           TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at           TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
);

CREATE TRIGGER trg_order_updated_at
  BEFORE UPDATE ON "order"
  FOR EACH ROW EXECUTE PROCEDURE update_updated_at_column();

CREATE INDEX idx_order_customer_id ON "order"(customer_id);
CREATE INDEX idx_order_promo_id ON "order"(promo_id);
CREATE INDEX idx_order_status ON "order"(status);
CREATE INDEX idx_order_date ON "order"(order_date);

-- 16. order_item - Items in specific orders
CREATE TABLE order_item (
  id           SERIAL    PRIMARY KEY,
  order_id     INTEGER   NOT NULL REFERENCES "order"(id) ON DELETE CASCADE,
  product_id   INTEGER   REFERENCES product(id) ON DELETE SET NULL,
  build_id     INTEGER   REFERENCES build(id) ON DELETE SET NULL,
  quantity     INTEGER   NOT NULL CHECK (quantity > 0),
  unit_price   NUMERIC(10,2) NOT NULL CHECK (unit_price >= 0),
  total_price  NUMERIC(10,2) NOT NULL CHECK (total_price >= 0),
  created_at   TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
  CHECK (
    (product_id IS NOT NULL AND build_id IS NULL)
    OR
    (product_id IS NULL AND build_id IS NOT NULL)
  )
);

CREATE INDEX idx_order_item_order_id ON order_item(order_id);
CREATE INDEX idx_order_item_product_id ON order_item(product_id);
CREATE INDEX idx_order_item_build_id ON order_item(build_id);

-- ============================================================================
-- CUSTOMER INTERACTION TABLES
-- ============================================================================

-- 17. product_qa - Product questions from customers
CREATE TABLE product_qa (
  id            SERIAL    PRIMARY KEY,
  product_id    INTEGER   NOT NULL REFERENCES product(id) ON DELETE CASCADE,
  customer_id   UUID      NOT NULL REFERENCES customer(id) ON DELETE CASCADE,
  question_text TEXT      NOT NULL,
  is_answered   BOOLEAN   NOT NULL DEFAULT FALSE,
  time_asked    TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_product_qa_product_id ON product_qa(product_id);
CREATE INDEX idx_product_qa_customer_id ON product_qa(customer_id);
CREATE INDEX idx_product_qa_answered ON product_qa(is_answered);

-- 18. qa_answer - Admin answers to product questions
CREATE TABLE qa_answer (
  id             SERIAL    PRIMARY KEY,
  question_id    INTEGER   NOT NULL REFERENCES product_qa(id) ON DELETE CASCADE,
  answer_text    TEXT      NOT NULL,
  time_answered  TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
  admin_id       UUID      REFERENCES admin(id) ON DELETE SET NULL
);

CREATE INDEX idx_qa_answer_question_id ON qa_answer(question_id);
CREATE INDEX idx_qa_answer_admin_id ON qa_answer(admin_id);

-- 19. review - Product reviews from customers
CREATE TABLE review (
  id            SERIAL    PRIMARY KEY,
  product_id    INTEGER   NOT NULL REFERENCES product(id) ON DELETE CASCADE,
  customer_id   UUID      NOT NULL REFERENCES customer(id) ON DELETE CASCADE,
  review_text   TEXT,
  rating        NUMERIC(2,1) NOT NULL CHECK (rating BETWEEN 0 AND 5),
  is_verified   BOOLEAN   NOT NULL DEFAULT FALSE,
  time_added    TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
  UNIQUE(product_id, customer_id)
);

CREATE INDEX idx_review_product_id ON review(product_id);
CREATE INDEX idx_review_customer_id ON review(customer_id);
CREATE INDEX idx_review_rating ON review(rating);

-- 20. wishlist - Customer product wishlists
CREATE TABLE wishlist (
  customer_id  UUID      NOT NULL REFERENCES customer(id) ON DELETE CASCADE,
  product_id   INTEGER   NOT NULL REFERENCES product(id) ON DELETE CASCADE,
  added_at     TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
  PRIMARY KEY (customer_id, product_id)
);

CREATE INDEX idx_wishlist_customer_id ON wishlist(customer_id);
CREATE INDEX idx_wishlist_product_id ON wishlist(product_id);

-- ============================================================================
-- COMMUNICATION TABLES
-- ============================================================================

-- 21. message - User-to-user messaging system
CREATE TABLE message (
  id            SERIAL    PRIMARY KEY,
  sender_id     UUID      NOT NULL REFERENCES general_user(id) ON DELETE CASCADE,
  receiver_id   UUID      NOT NULL REFERENCES general_user(id) ON DELETE CASCADE,
  message_text  TEXT      NOT NULL,
  seen_status   BOOLEAN   NOT NULL DEFAULT FALSE,
  sent_at       TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
  message_type  VARCHAR(20) NOT NULL DEFAULT 'text' CHECK (message_type IN ('text', 'image', 'file'))
);

CREATE INDEX idx_message_sender_id ON message(sender_id);
CREATE INDEX idx_message_receiver_id ON message(receiver_id);
CREATE INDEX idx_message_conversation ON message(sender_id, receiver_id);
CREATE INDEX idx_message_sent_at ON message(sent_at);

-- 22. notification - General user notifications
CREATE TABLE notification (
  id                 SERIAL    PRIMARY KEY,
  user_id            UUID      NOT NULL REFERENCES general_user(id) ON DELETE CASCADE,
  notification_text  TEXT      NOT NULL,
  seen_status        BOOLEAN   NOT NULL DEFAULT FALSE,
  notification_type  VARCHAR(50) DEFAULT 'general',
  link               TEXT,
  created_at         TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_notification_user_id ON notification(user_id);
CREATE INDEX idx_notification_seen ON notification(seen_status);
CREATE INDEX idx_notification_type ON notification(notification_type);

-- 23. admin_notification - Admin-specific notifications
CREATE TABLE admin_notification (
  id                 SERIAL    PRIMARY KEY,
  admin_id           UUID      REFERENCES admin(id) ON DELETE CASCADE,
  title              VARCHAR(200) NOT NULL,
  message            TEXT      NOT NULL,
  type               VARCHAR(50) NOT NULL CHECK (type IN (
    'NEW_ADMIN_REQUEST', 'LOW_STOCK', 'STOCK_REFILLED', 'NEW_ORDER',
    'ORDER_CANCELLED', 'SYSTEM_ALERT', 'PROMO_EXPIRED', 'PRODUCT_REVIEW'
  )),
  is_read            BOOLEAN   NOT NULL DEFAULT FALSE,
  link               TEXT,
  priority           VARCHAR(20) NOT NULL DEFAULT 'normal' CHECK (priority IN ('low', 'normal', 'high', 'urgent')),
  created_at         TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_admin_notification_admin_id ON admin_notification(admin_id);
CREATE INDEX idx_admin_notification_read ON admin_notification(is_read);
CREATE INDEX idx_admin_notification_type ON admin_notification(type);
CREATE INDEX idx_admin_notification_priority ON admin_notification(priority);

-- ============================================================================
-- ANALYTICS & LOGGING TABLES
-- ============================================================================

-- 24. admin_action_log - Audit trail for admin actions
CREATE TABLE admin_action_log (
  id          SERIAL    PRIMARY KEY,
  admin_id    UUID      NOT NULL REFERENCES admin(id) ON DELETE CASCADE,
  action      VARCHAR(100) NOT NULL,
  table_name  VARCHAR(50),
  record_id   VARCHAR(50),
  old_values  JSONB,
  new_values  JSONB,
  ip_address  INET,
  user_agent  TEXT,
  created_at  TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_admin_action_log_admin_id ON admin_action_log(admin_id);
CREATE INDEX idx_admin_action_log_action ON admin_action_log(action);
CREATE INDEX idx_admin_action_log_created_at ON admin_action_log(created_at);

-- 25. product_view_log - Product view tracking for analytics
CREATE TABLE product_view_log (
  id          SERIAL    PRIMARY KEY,
  product_id  INTEGER   NOT NULL REFERENCES product(id) ON DELETE CASCADE,
  customer_id UUID      REFERENCES customer(id) ON DELETE SET NULL,
  ip_address  INET,
  user_agent  TEXT,
  viewed_at   TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_product_view_log_product_id ON product_view_log(product_id);
CREATE INDEX idx_product_view_log_customer_id ON product_view_log(customer_id);
CREATE INDEX idx_product_view_log_viewed_at ON product_view_log(viewed_at);

-- ============================================================================
-- VIEWS FOR COMMON QUERIES
-- ============================================================================

-- Product details with category and stock information
CREATE VIEW product_details AS
SELECT 
  p.id,
  p.name,
  p.excerpt,
  p.image_url,
  p.price,
  p.discount_status,
  p.discount_percent,
  p.availability,
  p.specs,
  pc.name AS category_name,
  pa.stock,
  pa.units_sold,
  pa.cost,
  COALESCE(AVG(r.rating), 0) AS average_rating,
  COUNT(r.id) AS review_count
FROM product p
JOIN product_category pc ON p.category_id = pc.id
LEFT JOIN product_attribute pa ON p.id = pa.product_id
LEFT JOIN review r ON p.id = r.product_id
GROUP BY p.id, p.name, p.excerpt, p.image_url, p.price, 
         p.discount_status, p.discount_percent, p.availability, 
         p.specs, pc.name, pa.stock, pa.units_sold, pa.cost;

-- Order summary with customer and item details
CREATE VIEW order_summary AS
SELECT 
  o.id AS order_id,
  o.order_date,
  o.status,
  o.total_price,
  o.payment_status,
  gu.full_name AS customer_name,
  gu.email AS customer_email,
  COUNT(oi.id) AS item_count,
  SUM(oi.quantity) AS total_quantity
FROM "order" o
JOIN customer c ON o.customer_id = c.id
JOIN general_user gu ON c.user_id = gu.id
LEFT JOIN order_item oi ON o.id = oi.order_id
GROUP BY o.id, o.order_date, o.status, o.total_price, 
         o.payment_status, gu.full_name, gu.email;

-- Admin dashboard statistics
CREATE VIEW admin_dashboard_stats AS
SELECT 
  (SELECT COUNT(*) FROM "order" WHERE order_date = CURRENT_DATE) AS today_orders,
  (SELECT COUNT(*) FROM "order" WHERE status = 'pending') AS pending_orders,
  (SELECT COUNT(*) FROM product WHERE availability = true) AS active_products,
  (SELECT COUNT(*) FROM product_attribute WHERE stock < 10) AS low_stock_products,
  (SELECT COALESCE(SUM(total_price), 0) FROM "order" WHERE order_date = CURRENT_DATE) AS today_revenue,
  (SELECT COALESCE(SUM(total_price), 0) FROM "order" WHERE DATE_PART('month', order_date) = DATE_PART('month', CURRENT_DATE)) AS monthly_revenue,
  (SELECT COUNT(*) FROM customer WHERE DATE(created_at) = CURRENT_DATE) AS new_customers_today,
  (SELECT COUNT(*) FROM admin_notification WHERE is_read = false) AS unread_notifications;

-- ============================================================================
-- TRIGGERS AND FUNCTIONS
-- ============================================================================

-- Function to update product Q&A answered status when answer is added
CREATE OR REPLACE FUNCTION update_qa_answered_status()
RETURNS TRIGGER AS $$
BEGIN
  UPDATE product_qa 
  SET is_answered = true 
  WHERE id = NEW.question_id;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_qa_answer_update_status
  AFTER INSERT ON qa_answer
  FOR EACH ROW EXECUTE PROCEDURE update_qa_answered_status();

-- Function to update promo usage count
CREATE OR REPLACE FUNCTION update_promo_usage()
RETURNS TRIGGER AS $$
BEGIN
  IF NEW.promo_id IS NOT NULL THEN
    UPDATE promo 
    SET usage_count = usage_count + 1 
    WHERE id = NEW.promo_id;
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_order_update_promo_usage
  AFTER INSERT ON "order"
  FOR EACH ROW EXECUTE PROCEDURE update_promo_usage();

-- Function to update product units sold when order is placed
CREATE OR REPLACE FUNCTION update_product_sales()
RETURNS TRIGGER AS $$
BEGIN
  IF NEW.product_id IS NOT NULL THEN
    UPDATE product_attribute 
    SET units_sold = units_sold + NEW.quantity,
        stock = stock - NEW.quantity
    WHERE product_id = NEW.product_id;
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_order_item_update_sales
  AFTER INSERT ON order_item
  FOR EACH ROW EXECUTE PROCEDURE update_product_sales();

-- ============================================================================
-- SAMPLE DATA INSERTION (Optional)
-- ============================================================================

-- Insert default product categories
INSERT INTO product_category (name, description) VALUES
('Laptops', 'Portable computers for work and gaming'),
('Desktops', 'High-performance desktop computers'),
('Components', 'PC building components and parts'),
('Peripherals', 'Computer accessories and peripherals'),
('Gaming', 'Gaming-specific hardware and accessories'),
('Storage', 'Hard drives, SSDs, and storage solutions'),
('Networking', 'Routers, switches, and networking equipment');

-- Insert default admin clearance levels and sample admin
-- Note: You'll need to insert into general_user first, then admin

-- ============================================================================
-- PERFORMANCE OPTIMIZATIONS
-- ============================================================================

-- Composite indexes for common query patterns
CREATE INDEX idx_order_customer_status ON "order"(customer_id, status);
CREATE INDEX idx_product_category_availability ON product(category_id, availability);
CREATE INDEX idx_cart_item_cart_product ON cart_item(cart_id, product_id);
CREATE INDEX idx_notification_user_seen ON notification(user_id, seen_status);

-- Partial indexes for better performance
CREATE INDEX idx_active_products ON product(id) WHERE availability = true;
CREATE INDEX idx_unread_notifications ON notification(user_id) WHERE seen_status = false;
CREATE INDEX idx_pending_orders ON "order"(id) WHERE status = 'pending';

-- ============================================================================
-- CONSTRAINTS AND BUSINESS RULES
-- ============================================================================

-- Ensure cart items have positive quantities and prices
ALTER TABLE cart_item ADD CONSTRAINT chk_cart_item_positive_values 
  CHECK (quantity > 0 AND unit_price >= 0);

-- Ensure order items have positive quantities and prices
ALTER TABLE order_item ADD CONSTRAINT chk_order_item_positive_values 
  CHECK (quantity > 0 AND unit_price >= 0 AND total_price >= 0);

-- Ensure promo dates are logical
ALTER TABLE promo ADD CONSTRAINT chk_promo_dates 
  CHECK (end_date > start_date);

-- Ensure product prices and discounts are valid
ALTER TABLE product ADD CONSTRAINT chk_product_discount 
  CHECK (
    (discount_status = false AND discount_percent = 0) OR 
    (discount_status = true AND discount_percent > 0)
  );

-- ============================================================================
-- DATABASE DOCUMENTATION
-- ============================================================================

COMMENT ON TABLE general_user IS 'Base user table containing common user information for all platform users';
COMMENT ON TABLE admin IS 'Admin users with role-based access control and clearance levels';
COMMENT ON TABLE customer IS 'Customer-specific information and loyalty points';
COMMENT ON TABLE product IS 'Main product catalog with pricing and availability';
COMMENT ON TABLE product_attribute IS 'Product inventory management and cost tracking';
COMMENT ON TABLE "order" IS 'Customer orders with payment and shipping information';
COMMENT ON TABLE order_item IS 'Individual items within orders for detailed tracking';
COMMENT ON TABLE cart IS 'Customer shopping carts for temporary item storage';
COMMENT ON TABLE build IS 'Custom PC builds created by customers';
COMMENT ON TABLE promo IS 'Promotional codes and discount management';
COMMENT ON TABLE admin_notification IS 'Admin-specific notifications for system events';

-- ============================================================================
-- ADDITIONAL TABLES (found in database implementation)
-- ============================================================================

-- 26. compatibility_rules - PC component compatibility validation rules
CREATE TABLE compatibility_rules (
  id               SERIAL    PRIMARY KEY,
  rule_type        VARCHAR(50) NOT NULL,
  category1_id     INTEGER   REFERENCES product_category(id) ON DELETE CASCADE,
  category2_id     INTEGER   REFERENCES product_category(id) ON DELETE CASCADE,
  spec1_field      VARCHAR(100),
  spec2_field      VARCHAR(100),
  rule_description TEXT,
  is_active        BOOLEAN   DEFAULT TRUE,
  created_at       TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_compatibility_rules_category1 ON compatibility_rules(category1_id);
CREATE INDEX idx_compatibility_rules_category2 ON compatibility_rules(category2_id);
CREATE INDEX idx_compatibility_rules_active ON compatibility_rules(is_active);

COMMENT ON TABLE compatibility_rules IS 'Rules for validating PC component compatibility during builds';

-- 27. ratings - Product ratings and reviews (enhanced version of review table)
CREATE TABLE ratings (
  id            UUID      PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id       UUID      NOT NULL REFERENCES general_user(id) ON DELETE CASCADE,
  product_id    INTEGER   NOT NULL REFERENCES product(id) ON DELETE CASCADE,
  rating        INTEGER   NOT NULL CHECK (rating BETWEEN 1 AND 5),
  review_text   TEXT,
  order_id      INTEGER   REFERENCES "order"(id) ON DELETE SET NULL,
  order_item_id INTEGER   REFERENCES order_item(id) ON DELETE SET NULL,
  created_at    TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_at    TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  UNIQUE(user_id, product_id)
);

CREATE TRIGGER trg_ratings_updated_at
  BEFORE UPDATE ON ratings
  FOR EACH ROW EXECUTE PROCEDURE update_updated_at_column();

CREATE INDEX idx_ratings_user_id ON ratings(user_id);
CREATE INDEX idx_ratings_product_id ON ratings(product_id);
CREATE INDEX idx_ratings_rating ON ratings(rating);
CREATE INDEX idx_ratings_created_at ON ratings(created_at);

COMMENT ON TABLE ratings IS 'Enhanced product ratings and reviews system with order verification';

-- End of schema
