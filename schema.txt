-- =====================================================
-- LogicBuilders E-commerce Database Schema
-- Complete Database Structure with All Dependencies
-- Version: 2025-07-27
-- =====================================================

-- USAGE INSTRUCTIONS:
-- 1. Create database: CREATE DATABASE logicbuilders;
-- 2. Run this schema: psql -U username -d logicbuilders -f schema.txt  
-- 3. Configure environment variables in server/.env
-- 4. Import product data if available
-- 5. Create first admin through signup process

-- REQUIRED ENVIRONMENT VARIABLES (.env):
-- DB_USER=your_db_username
-- DB_PASSWORD=your_db_password  
-- DB_HOST=localhost
-- DB_PORT=5432
-- DB_NAME=logicbuilders
-- JWT_SECRET=your_jwt_secret_key

-- Enable UUID extension first
CREATE EXTENSION IF NOT EXISTS "uuid-ossp" WITH SCHEMA public;

-- =====================================================
-- CORE USER TABLES
-- =====================================================

-- Base user table for all system users
CREATE TABLE public.general_user (
    id uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    username character varying(100) NOT NULL,
    email character varying(100) NOT NULL,
    password_hash text NOT NULL,
    contact_no character varying(20),
    profile_img text,
    full_name character varying(100) NOT NULL,
    gender character varying(10),
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP NOT NULL,
    updated_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP NOT NULL,
    CONSTRAINT general_user_pkey PRIMARY KEY (id),
    CONSTRAINT general_user_contact_no_key UNIQUE (contact_no),
    CONSTRAINT general_user_email_key UNIQUE (email),
    CONSTRAINT general_user_username_key UNIQUE (username)
);

-- Customer extension table
CREATE TABLE public.customer (
    id uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    user_id uuid NOT NULL,
    points integer DEFAULT 0 NOT NULL,
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP NOT NULL,
    updated_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP NOT NULL,
    CONSTRAINT customer_pkey PRIMARY KEY (id),
    CONSTRAINT customer_points_check CHECK ((points >= 0)),
    CONSTRAINT customer_user_id_fkey FOREIGN KEY (user_id) REFERENCES public.general_user(id) ON DELETE CASCADE
);

-- =====================================================
-- ADMIN SYSTEM TABLES
-- =====================================================

-- Access levels for role-based permissions
CREATE TABLE public.access_levels (
    access_level integer NOT NULL,
    access_name character varying(100) NOT NULL,
    description text,
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    updated_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT access_levels_pkey PRIMARY KEY (access_level)
);

-- Admin users with clearance-based access
CREATE TABLE public.admin_users (
    employee_id character varying(50) NOT NULL,
    name character varying(100) NOT NULL,
    password text NOT NULL,
    is_active boolean DEFAULT true,
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    updated_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    clearance_level integer,
    email character varying(100),
    phone character varying(20),
    department character varying(100),
    "position" character varying(100),
    is_employed boolean DEFAULT true,
    admin_id uuid NOT NULL,
    user_id uuid NOT NULL,
    CONSTRAINT admin_users_pkey PRIMARY KEY (admin_id),
    CONSTRAINT admin_users_email_key UNIQUE (email),
    CONSTRAINT admin_users_employee_id_key UNIQUE (employee_id),
    CONSTRAINT fk_admin_clearance_level FOREIGN KEY (clearance_level) REFERENCES public.access_levels(access_level),
    CONSTRAINT fk_admin_users_user_id FOREIGN KEY (user_id) REFERENCES public.general_user(id) ON DELETE CASCADE
);

-- Admin signup requests
CREATE TABLE public.admin_signup_requests (
    request_id SERIAL PRIMARY KEY,
    employee_id character varying(50) NOT NULL,
    name character varying(100) NOT NULL,
    email character varying(100) NOT NULL,
    password text NOT NULL,
    phone character varying(20),
    department character varying(100),
    "position" character varying(100),
    reason_for_access text,
    status character varying(20) DEFAULT 'PENDING'::character varying,
    approved_at timestamp without time zone,
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    updated_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    requested_clearance integer,
    assigned_clearance integer,
    approved_by uuid,
    CONSTRAINT admin_signup_requests_status_check CHECK (((status)::text = ANY ((ARRAY['PENDING'::character varying, 'APPROVED'::character varying, 'REJECTED'::character varying])::text[]))),
    CONSTRAINT admin_signup_requests_approved_by_fkey FOREIGN KEY (approved_by) REFERENCES public.admin_users(admin_id),
    CONSTRAINT fk_signup_assigned_clearance FOREIGN KEY (assigned_clearance) REFERENCES public.access_levels(access_level),
    CONSTRAINT fk_signup_requested_clearance FOREIGN KEY (requested_clearance) REFERENCES public.access_levels(access_level)
);

-- Admin activity logs
CREATE TABLE public.admin_logs (
    log_id SERIAL PRIMARY KEY,
    action character varying(100) NOT NULL,
    target_type character varying(50),
    target_id character varying(100),
    details jsonb,
    ip_address inet,
    user_agent text,
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    admin_id uuid,
    CONSTRAINT admin_logs_admin_id_fkey FOREIGN KEY (admin_id) REFERENCES public.admin_users(admin_id)
);

-- Admin notifications
CREATE TABLE public.admin_notifications (
    notification_id SERIAL PRIMARY KEY,
    type character varying(50) NOT NULL,
    title character varying(200) NOT NULL,
    message text NOT NULL,
    related_id integer,
    is_read boolean DEFAULT false,
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    admin_id uuid,
    CONSTRAINT admin_notifications_admin_id_fkey FOREIGN KEY (admin_id) REFERENCES public.admin_users(admin_id)
);

-- Legacy admin table (for compatibility)
CREATE TABLE public.admin (
    id uuid DEFAULT public.uuid_generate_v4() NOT NULL,
    user_id uuid NOT NULL,
    clearance_level character varying(30) NOT NULL,
    is_employed boolean DEFAULT true NOT NULL,
    hire_date timestamp without time zone DEFAULT CURRENT_TIMESTAMP NOT NULL,
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP NOT NULL,
    updated_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP NOT NULL,
    CONSTRAINT admin_pkey PRIMARY KEY (id),
    CONSTRAINT admin_user_id_fkey FOREIGN KEY (user_id) REFERENCES public.general_user(id) ON DELETE CASCADE
);

-- =====================================================
-- PRODUCT CATALOG SYSTEM
-- =====================================================

-- Product categories
CREATE TABLE public.product_category (
    id SERIAL PRIMARY KEY,
    name character varying(100) NOT NULL,
    description text,
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP NOT NULL,
    updated_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP NOT NULL,
    CONSTRAINT product_category_name_key UNIQUE (name)
);

-- Products
CREATE TABLE public.product (
    id SERIAL PRIMARY KEY,
    name character varying(200) NOT NULL,
    excerpt text,
    image_url text,
    price numeric(10,2) NOT NULL,
    discount_status boolean DEFAULT false NOT NULL,
    discount_percent numeric(5,2) DEFAULT 0 NOT NULL,
    availability boolean DEFAULT true NOT NULL,
    date_added date DEFAULT CURRENT_DATE NOT NULL,
    category_id integer NOT NULL,
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP NOT NULL,
    updated_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP NOT NULL,
    specs jsonb DEFAULT '{}'::jsonb,
    CONSTRAINT product_discount_percent_check CHECK (((discount_percent >= (0)::numeric) AND (discount_percent <= (100)::numeric))),
    CONSTRAINT product_price_check CHECK ((price >= (0)::numeric)),
    CONSTRAINT product_category_id_fkey FOREIGN KEY (category_id) REFERENCES public.product_category(id) ON DELETE CASCADE
);

-- Product attributes (stock, dimensions, etc.)
CREATE TABLE public.product_attribute (
    id SERIAL PRIMARY KEY,
    product_id integer NOT NULL,
    length numeric(8,2),
    width numeric(8,2),
    height numeric(8,2),
    weight numeric(8,2),
    stock integer DEFAULT 0 NOT NULL,
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP NOT NULL,
    updated_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP NOT NULL,
    CONSTRAINT product_attribute_stock_check CHECK ((stock >= 0)),
    CONSTRAINT product_attribute_product_id_fkey FOREIGN KEY (product_id) REFERENCES public.product(id) ON DELETE CASCADE
);

-- =====================================================
-- SHOPPING CART & ORDER SYSTEM
-- =====================================================

-- Shopping carts
CREATE TABLE public.cart (
    id SERIAL PRIMARY KEY,
    customer_id uuid NOT NULL,
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP NOT NULL,
    updated_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP NOT NULL,
    CONSTRAINT cart_customer_id_fkey FOREIGN KEY (customer_id) REFERENCES public.customer(id) ON DELETE CASCADE
);

-- Cart items
CREATE TABLE public.cart_item (
    id SERIAL PRIMARY KEY,
    cart_id integer NOT NULL,
    product_id integer,
    build_id integer,
    quantity integer DEFAULT 1 NOT NULL,
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP NOT NULL,
    CONSTRAINT cart_item_quantity_check CHECK ((quantity > 0)),
    CONSTRAINT cart_item_cart_id_fkey FOREIGN KEY (cart_id) REFERENCES public.cart(id) ON DELETE CASCADE,
    CONSTRAINT cart_item_product_id_fkey FOREIGN KEY (product_id) REFERENCES public.product(id) ON DELETE CASCADE
);

-- Shipping addresses
CREATE TABLE public.shipping_address (
    id SERIAL PRIMARY KEY,
    customer_id uuid NOT NULL,
    address_line1 character varying(255) NOT NULL,
    address_line2 character varying(255),
    city character varying(100) NOT NULL,
    state character varying(100),
    postal_code character varying(20) NOT NULL,
    country character varying(100) NOT NULL,
    is_default boolean DEFAULT false NOT NULL,
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP NOT NULL,
    updated_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP NOT NULL,
    CONSTRAINT shipping_address_customer_id_fkey FOREIGN KEY (customer_id) REFERENCES public.customer(id) ON DELETE CASCADE
);

-- Promotions/Coupons
CREATE TABLE public.promo (
    id SERIAL PRIMARY KEY,
    name character varying(100) NOT NULL,
    description text,
    discount_percent numeric(5,2) DEFAULT 0 NOT NULL,
    discount_amount numeric(10,2) DEFAULT 0 NOT NULL,
    start_date timestamp without time zone DEFAULT CURRENT_TIMESTAMP NOT NULL,
    end_date timestamp without time zone,
    is_active boolean DEFAULT true NOT NULL,
    usage_limit integer,
    current_usage integer DEFAULT 0 NOT NULL,
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP NOT NULL,
    updated_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP NOT NULL,
    CONSTRAINT promo_name_key UNIQUE (name),
    CONSTRAINT promo_current_usage_check CHECK ((current_usage >= 0)),
    CONSTRAINT promo_discount_amount_check CHECK ((discount_amount >= (0)::numeric)),
    CONSTRAINT promo_discount_percent_check CHECK (((discount_percent >= (0)::numeric) AND (discount_percent <= (100)::numeric))),
    CONSTRAINT promo_usage_limit_check CHECK ((usage_limit > 0))
);

-- Orders
CREATE TABLE public."order" (
    id SERIAL PRIMARY KEY,
    customer_id uuid NOT NULL,
    order_date timestamp without time zone DEFAULT CURRENT_TIMESTAMP NOT NULL,
    status character varying(50) DEFAULT 'pending'::character varying NOT NULL,
    total_amount numeric(12,2) NOT NULL,
    shipping_amount numeric(10,2) DEFAULT 0 NOT NULL,
    tax_amount numeric(10,2) DEFAULT 0 NOT NULL,
    discount_amount numeric(10,2) DEFAULT 0 NOT NULL,
    final_amount numeric(12,2) NOT NULL,
    shipping_address_id integer NOT NULL,
    promo_id integer,
    payment_method character varying(50),
    payment_status character varying(50) DEFAULT 'pending'::character varying,
    tracking_number character varying(100),
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP NOT NULL,
    updated_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP NOT NULL,
    CONSTRAINT order_discount_amount_check CHECK ((discount_amount >= (0)::numeric)),
    CONSTRAINT order_final_amount_check CHECK ((final_amount >= (0)::numeric)),
    CONSTRAINT order_shipping_amount_check CHECK ((shipping_amount >= (0)::numeric)),
    CONSTRAINT order_tax_amount_check CHECK ((tax_amount >= (0)::numeric)),
    CONSTRAINT order_total_amount_check CHECK ((total_amount >= (0)::numeric)),
    CONSTRAINT order_customer_id_fkey FOREIGN KEY (customer_id) REFERENCES public.customer(id) ON DELETE CASCADE,
    CONSTRAINT order_promo_id_fkey FOREIGN KEY (promo_id) REFERENCES public.promo(id) ON DELETE SET NULL,
    CONSTRAINT order_shipping_address_id_fkey FOREIGN KEY (shipping_address_id) REFERENCES public.shipping_address(id) ON DELETE CASCADE
);

-- Order items
CREATE TABLE public.order_item (
    id SERIAL PRIMARY KEY,
    order_id integer NOT NULL,
    product_id integer,
    build_id integer,
    quantity integer DEFAULT 1 NOT NULL,
    unit_price numeric(10,2) NOT NULL,
    total_price numeric(12,2) NOT NULL,
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP NOT NULL,
    CONSTRAINT order_item_quantity_check CHECK ((quantity > 0)),
    CONSTRAINT order_item_total_price_check CHECK ((total_price >= (0)::numeric)),
    CONSTRAINT order_item_unit_price_check CHECK ((unit_price >= (0)::numeric)),
    CONSTRAINT order_item_order_id_fkey FOREIGN KEY (order_id) REFERENCES public."order"(id) ON DELETE CASCADE,
    CONSTRAINT order_item_product_id_fkey FOREIGN KEY (product_id) REFERENCES public.product(id) ON DELETE SET NULL
);

-- =====================================================
-- PC BUILD SYSTEM
-- =====================================================

-- Build templates
CREATE TABLE public.template (
    id SERIAL PRIMARY KEY,
    name character varying(100) NOT NULL,
    description text,
    category character varying(50),
    price_range character varying(50),
    is_active boolean DEFAULT true NOT NULL,
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP NOT NULL,
    updated_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP NOT NULL
);

-- Template products (components in templates)
CREATE TABLE public.template_product (
    id SERIAL PRIMARY KEY,
    template_id integer NOT NULL,
    product_id integer NOT NULL,
    component_type character varying(50) NOT NULL,
    is_required boolean DEFAULT true NOT NULL,
    quantity integer DEFAULT 1 NOT NULL,
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP NOT NULL,
    CONSTRAINT template_product_quantity_check CHECK ((quantity > 0)),
    CONSTRAINT template_product_product_id_fkey FOREIGN KEY (product_id) REFERENCES public.product(id) ON DELETE CASCADE,
    CONSTRAINT template_product_template_id_fkey FOREIGN KEY (template_id) REFERENCES public.template(id) ON DELETE CASCADE
);

-- Customer builds
CREATE TABLE public.build (
    id SERIAL PRIMARY KEY,
    customer_id uuid NOT NULL,
    template_id integer,
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP NOT NULL,
    updated_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT build_customer_id_fkey FOREIGN KEY (customer_id) REFERENCES public.customer(id) ON DELETE CASCADE,
    CONSTRAINT build_template_id_fkey FOREIGN KEY (template_id) REFERENCES public.template(id) ON DELETE SET NULL
);

-- Build products (actual components in customer builds)
CREATE TABLE public.build_product (
    id SERIAL PRIMARY KEY,
    build_id integer NOT NULL,
    product_id integer NOT NULL,
    component_type character varying(50) NOT NULL,
    quantity integer DEFAULT 1 NOT NULL,
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP NOT NULL,
    CONSTRAINT build_product_quantity_check CHECK ((quantity > 0)),
    CONSTRAINT build_product_build_id_fkey FOREIGN KEY (build_id) REFERENCES public.build(id) ON DELETE CASCADE,
    CONSTRAINT build_product_product_id_fkey FOREIGN KEY (product_id) REFERENCES public.product(id) ON DELETE CASCADE
);

-- Add foreign key for cart_item build_id
ALTER TABLE public.cart_item ADD CONSTRAINT cart_item_build_id_fkey FOREIGN KEY (build_id) REFERENCES public.build(id) ON DELETE CASCADE;
ALTER TABLE public.order_item ADD CONSTRAINT order_item_build_id_fkey FOREIGN KEY (build_id) REFERENCES public.build(id) ON DELETE SET NULL;

-- Compatibility rules for PC components
CREATE TABLE public.compatibility_rules (
    id SERIAL PRIMARY KEY,
    category1_id integer NOT NULL,
    category2_id integer NOT NULL,
    rule_type character varying(20) NOT NULL,
    description text,
    is_active boolean DEFAULT true,
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    updated_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT compatibility_rules_rule_type_check CHECK (((rule_type)::text = ANY ((ARRAY['compatible'::character varying, 'incompatible'::character varying, 'required'::character varying])::text[]))),
    CONSTRAINT compatibility_rules_category1_id_fkey FOREIGN KEY (category1_id) REFERENCES public.product_category(id) ON DELETE CASCADE,
    CONSTRAINT compatibility_rules_category2_id_fkey FOREIGN KEY (category2_id) REFERENCES public.product_category(id) ON DELETE CASCADE
);

-- =====================================================
-- REVIEW & RATING SYSTEM
-- =====================================================

-- Product ratings (updated to 1-10 scale)
CREATE TABLE public.ratings (
    id uuid DEFAULT gen_random_uuid() NOT NULL,
    user_id uuid NOT NULL,
    product_id integer NOT NULL,
    rating integer NOT NULL,
    review_text text,
    order_id integer,
    order_item_id integer,
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    updated_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT ratings_pkey PRIMARY KEY (id),
    CONSTRAINT ratings_user_id_product_id_key UNIQUE (user_id, product_id),
    CONSTRAINT ratings_rating_check CHECK (((rating >= 1) AND (rating <= 10))),
    CONSTRAINT ratings_order_id_fkey FOREIGN KEY (order_id) REFERENCES public."order"(id) ON DELETE SET NULL,
    CONSTRAINT ratings_order_item_id_fkey FOREIGN KEY (order_item_id) REFERENCES public.order_item(id) ON DELETE SET NULL,
    CONSTRAINT ratings_product_id_fkey FOREIGN KEY (product_id) REFERENCES public.product(id) ON DELETE CASCADE,
    CONSTRAINT ratings_user_id_fkey FOREIGN KEY (user_id) REFERENCES public.general_user(id) ON DELETE CASCADE
);

-- Legacy review table (keep for compatibility)
CREATE TABLE public.review (
    id SERIAL PRIMARY KEY,
    customer_id uuid NOT NULL,
    product_id integer NOT NULL,
    rating integer NOT NULL,
    review_text text,
    review_date timestamp without time zone DEFAULT CURRENT_TIMESTAMP NOT NULL,
    CONSTRAINT review_rating_check CHECK (((rating >= 1) AND (rating <= 5))),
    CONSTRAINT review_customer_id_fkey FOREIGN KEY (customer_id) REFERENCES public.customer(id) ON DELETE CASCADE,
    CONSTRAINT review_product_id_fkey FOREIGN KEY (product_id) REFERENCES public.product(id) ON DELETE CASCADE
);

-- =====================================================
-- Q&A SYSTEM
-- =====================================================

-- Product Q&A
CREATE TABLE public.product_qa (
    id SERIAL PRIMARY KEY,
    product_id integer NOT NULL,
    customer_id uuid NOT NULL,
    question_text text NOT NULL,
    time_asked timestamp without time zone DEFAULT CURRENT_TIMESTAMP NOT NULL,
    priority character varying(10) DEFAULT 'normal'::character varying,
    status character varying(20) DEFAULT 'pending'::character varying,
    category character varying(50),
    updated_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT product_qa_priority_check CHECK (((priority)::text = ANY ((ARRAY['low'::character varying, 'normal'::character varying, 'high'::character varying, 'urgent'::character varying])::text[]))),
    CONSTRAINT product_qa_status_check CHECK (((status)::text = ANY ((ARRAY['pending'::character varying, 'answered'::character varying, 'published'::character varying, 'archived'::character varying])::text[]))),
    CONSTRAINT product_qa_customer_id_fkey FOREIGN KEY (customer_id) REFERENCES public.customer(id) ON DELETE CASCADE,
    CONSTRAINT product_qa_product_id_fkey FOREIGN KEY (product_id) REFERENCES public.product(id) ON DELETE CASCADE
);

-- Q&A answers
CREATE TABLE public.qa_answer (
    id SERIAL PRIMARY KEY,
    question_id integer NOT NULL,
    answer_text text,
    time_answered timestamp without time zone DEFAULT CURRENT_TIMESTAMP NOT NULL,
    admin_id uuid,
    is_published boolean DEFAULT false,
    send_to_customer boolean DEFAULT false,
    updated_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT qa_answer_admin_id_fkey FOREIGN KEY (admin_id) REFERENCES public.admin_users(admin_id) ON DELETE SET NULL,
    CONSTRAINT qa_answer_question_id_fkey FOREIGN KEY (question_id) REFERENCES public.product_qa(id) ON DELETE CASCADE
);

-- =====================================================
-- MESSAGING & COMMUNICATION
-- =====================================================

-- Conversations
CREATE TABLE public.conversation (
    id SERIAL PRIMARY KEY,
    title character varying(255) NOT NULL,
    type character varying(50) DEFAULT 'support'::character varying NOT NULL,
    status character varying(20) DEFAULT 'active'::character varying NOT NULL,
    priority character varying(10) DEFAULT 'normal'::character varying,
    created_by uuid NOT NULL,
    assigned_to uuid,
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP NOT NULL,
    updated_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP NOT NULL,
    last_message_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT conversation_priority_check CHECK (((priority)::text = ANY ((ARRAY['low'::character varying, 'normal'::character varying, 'high'::character varying, 'urgent'::character varying])::text[]))),
    CONSTRAINT conversation_status_check CHECK (((status)::text = ANY ((ARRAY['active'::character varying, 'closed'::character varying, 'pending'::character varying, 'resolved'::character varying])::text[]))),
    CONSTRAINT conversation_type_check CHECK (((type)::text = ANY ((ARRAY['support'::character varying, 'inquiry'::character varying, 'complaint'::character varying, 'feedback'::character varying])::text[]))),
    CONSTRAINT conversation_assigned_to_fkey FOREIGN KEY (assigned_to) REFERENCES public.general_user(id) ON DELETE SET NULL,
    CONSTRAINT conversation_created_by_fkey FOREIGN KEY (created_by) REFERENCES public.general_user(id) ON DELETE CASCADE
);

-- Conversation participants
CREATE TABLE public.conversation_participant (
    id SERIAL PRIMARY KEY,
    conversation_id integer NOT NULL,
    user_id uuid NOT NULL,
    joined_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP NOT NULL,
    role character varying(20) DEFAULT 'participant'::character varying,
    CONSTRAINT conversation_participant_role_check CHECK (((role)::text = ANY ((ARRAY['participant'::character varying, 'admin'::character varying, 'observer'::character varying])::text[]))),
    CONSTRAINT conversation_participant_conversation_id_fkey FOREIGN KEY (conversation_id) REFERENCES public.conversation(id) ON DELETE CASCADE,
    CONSTRAINT conversation_participant_user_id_fkey FOREIGN KEY (user_id) REFERENCES public.general_user(id) ON DELETE CASCADE
);

-- Messages
CREATE TABLE public.message (
    id SERIAL PRIMARY KEY,
    sender_id uuid NOT NULL,
    receiver_id uuid,
    conversation_id integer,
    subject character varying(255),
    message_text text NOT NULL,
    message_type character varying(20) DEFAULT 'text'::character varying,
    priority character varying(10) DEFAULT 'normal'::character varying,
    message_status character varying(20) DEFAULT 'sent'::character varying,
    is_read boolean DEFAULT false,
    is_system_message boolean DEFAULT false,
    sent_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP NOT NULL,
    read_at timestamp without time zone,
    parent_message_id integer,
    CONSTRAINT message_message_status_check CHECK (((message_status)::text = ANY ((ARRAY['sent'::character varying, 'delivered'::character varying, 'read'::character varying, 'failed'::character varying])::text[]))),
    CONSTRAINT message_message_type_check CHECK (((message_type)::text = ANY ((ARRAY['text'::character varying, 'html'::character varying, 'system'::character varying])::text[]))),
    CONSTRAINT message_priority_check CHECK (((priority)::text = ANY ((ARRAY['low'::character varying, 'normal'::character varying, 'high'::character varying, 'urgent'::character varying])::text[]))),
    CONSTRAINT message_parent_message_id_fkey FOREIGN KEY (parent_message_id) REFERENCES public.message(id) ON DELETE SET NULL,
    CONSTRAINT message_receiver_id_fkey FOREIGN KEY (receiver_id) REFERENCES public.general_user(id) ON DELETE CASCADE,
    CONSTRAINT message_sender_id_fkey FOREIGN KEY (sender_id) REFERENCES public.general_user(id) ON DELETE CASCADE
);

-- =====================================================
-- NOTIFICATION SYSTEM
-- =====================================================

-- User notifications
CREATE TABLE public.notification (
    id SERIAL PRIMARY KEY,
    user_id uuid NOT NULL,
    notification_text text NOT NULL,
    seen_status boolean DEFAULT false NOT NULL,
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP NOT NULL,
    notification_type character varying(50) DEFAULT 'general'::character varying,
    category character varying(50) DEFAULT 'general'::character varying,
    action_url text,
    expires_at timestamp without time zone,
    priority character varying(10) DEFAULT 'normal'::character varying,
    data jsonb DEFAULT '{}'::jsonb,
    link text,
    CONSTRAINT notification_priority_check CHECK (((priority)::text = ANY ((ARRAY['low'::character varying, 'normal'::character varying, 'high'::character varying, 'urgent'::character varying])::text[]))),
    CONSTRAINT notification_user_id_fkey FOREIGN KEY (user_id) REFERENCES public.general_user(id) ON DELETE CASCADE
);

-- =====================================================
-- ADVANCED PROMOTIONS SYSTEM
-- =====================================================

-- Advanced promotions with more features
CREATE TABLE public.promotions (
    id SERIAL PRIMARY KEY,
    code character varying(50) NOT NULL,
    name character varying(100) NOT NULL,
    description text,
    type character varying(20) NOT NULL,
    value numeric(10,2) NOT NULL,
    min_order_amount numeric(10,2) DEFAULT 0,
    max_discount_amount numeric(10,2),
    start_date timestamp without time zone NOT NULL,
    end_date timestamp without time zone NOT NULL,
    usage_limit integer,
    usage_count integer DEFAULT 0,
    is_active boolean DEFAULT true,
    created_by uuid NOT NULL,
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    updated_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT promotions_code_key UNIQUE (code),
    CONSTRAINT promotions_type_check CHECK (((type)::text = ANY ((ARRAY['percentage'::character varying, 'fixed_amount'::character varying, 'free_shipping'::character varying])::text[]))),
    CONSTRAINT promotions_created_by_fkey FOREIGN KEY (created_by) REFERENCES public.admin_users(admin_id)
);

-- Promotion usage tracking
CREATE TABLE public.promotion_usage (
    id SERIAL PRIMARY KEY,
    promotion_id integer NOT NULL,
    user_id uuid NOT NULL,
    order_id integer,
    used_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    discount_amount numeric(10,2),
    CONSTRAINT promotion_usage_promotion_id_fkey FOREIGN KEY (promotion_id) REFERENCES public.promotions(id) ON DELETE CASCADE
);

-- =====================================================
-- WISHLIST SYSTEM
-- =====================================================

-- Customer wishlists
CREATE TABLE public.wishlist (
    customer_id uuid NOT NULL,
    product_id integer NOT NULL,
    added_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP NOT NULL,
    CONSTRAINT wishlist_pkey PRIMARY KEY (customer_id, product_id),
    CONSTRAINT wishlist_customer_id_fkey FOREIGN KEY (customer_id) REFERENCES public.customer(id) ON DELETE CASCADE,
    CONSTRAINT wishlist_product_id_fkey FOREIGN KEY (product_id) REFERENCES public.product(id) ON DELETE CASCADE
);

-- =====================================================
-- TRIGGERS & FUNCTIONS
-- =====================================================

-- Function: Check cart stock before adding items
CREATE OR REPLACE FUNCTION public.check_cart_stock() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
    current_stock INTEGER;
    current_cart_quantity INTEGER;
    total_quantity INTEGER;
BEGIN
    -- Get current stock for the product
    SELECT stock INTO current_stock
    FROM product_attribute
    WHERE product_id = NEW.product_id;
    
    -- Get current quantity in cart for this product and customer
    SELECT COALESCE(SUM(quantity), 0) INTO current_cart_quantity
    FROM cart_item ci
    JOIN cart c ON ci.cart_id = c.id
    WHERE c.customer_id = (
        SELECT customer_id 
        FROM cart 
        WHERE id = NEW.cart_id
    ) AND ci.product_id = NEW.product_id
    AND ci.id != COALESCE(NEW.id, -1);
    
    -- Calculate total quantity if this item is added/updated
    total_quantity := current_cart_quantity + NEW.quantity;
    
    -- Check if total quantity exceeds stock
    IF total_quantity > current_stock THEN
        RAISE EXCEPTION 'Cannot add % items to cart. Only % items available (% already in cart)', 
            NEW.quantity, current_stock, current_cart_quantity;
    END IF;
    
    RETURN NEW;
END;
$$;

-- Function: Check order stock before placing order
CREATE OR REPLACE FUNCTION public.check_order_stock() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
    current_stock INTEGER;
BEGIN
    -- Get current stock for the product
    SELECT stock INTO current_stock
    FROM product_attribute
    WHERE product_id = NEW.product_id;
    
    -- Check if quantity exceeds stock
    IF NEW.quantity > current_stock THEN
        RAISE EXCEPTION 'Cannot order % items. Only % items available in stock', 
            NEW.quantity, current_stock;
    END IF;
    
    RETURN NEW;
END;
$$;

-- Function: Handle stock changes when orders are placed/cancelled
CREATE OR REPLACE FUNCTION public.handle_order_stock() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
    item RECORD;
BEGIN
    IF TG_OP = 'INSERT' THEN
        -- Order is being placed, decrease stock
        FOR item IN 
            SELECT product_id, quantity 
            FROM order_item 
            WHERE order_id = NEW.id
        LOOP
            UPDATE product_attribute 
            SET stock = stock - item.quantity
            WHERE product_id = item.product_id;
            
            -- Safety check for negative stock
            UPDATE product_attribute 
            SET stock = 0 
            WHERE product_id = item.product_id AND stock < 0;
        END LOOP;
        
    ELSIF TG_OP = 'UPDATE' THEN
        -- Check if order status changed to cancelled
        IF OLD.status != 'cancelled' AND NEW.status = 'cancelled' THEN
            -- Order is being cancelled, restore stock
            FOR item IN 
                SELECT product_id, quantity 
                FROM order_item 
                WHERE order_id = NEW.id
            LOOP
                UPDATE product_attribute 
                SET stock = stock + item.quantity
                WHERE product_id = item.product_id;
            END LOOP;
        ELSIF OLD.status = 'cancelled' AND NEW.status != 'cancelled' THEN
            -- Order is being uncancelled, decrease stock again
            FOR item IN 
                SELECT product_id, quantity 
                FROM order_item 
                WHERE order_id = NEW.id
            LOOP
                UPDATE product_attribute 
                SET stock = stock - item.quantity
                WHERE product_id = item.product_id;
                
                -- Safety check for negative stock
                UPDATE product_attribute 
                SET stock = 0 
                WHERE product_id = item.product_id AND stock < 0;
            END LOOP;
        END IF;
    END IF;
    
    RETURN COALESCE(NEW, OLD);
END;
$$;

-- Function: Update product availability when stock changes
CREATE OR REPLACE FUNCTION public.update_product_availability() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    IF TG_OP = 'UPDATE' THEN
        -- Check if stock changed from positive to 0
        IF OLD.stock > 0 AND NEW.stock = 0 THEN
            UPDATE product 
            SET availability = false 
            WHERE id = NEW.product_id;
        END IF;
        
        -- Check if stock changed from 0 to positive
        IF OLD.stock = 0 AND NEW.stock > 0 THEN
            UPDATE product 
            SET availability = true 
            WHERE id = NEW.product_id;
        END IF;
    END IF;
    
    IF TG_OP = 'INSERT' THEN
        -- Set availability based on initial stock
        IF NEW.stock = 0 THEN
            UPDATE product 
            SET availability = false 
            WHERE id = NEW.product_id;
        ELSE
            UPDATE product 
            SET availability = true 
            WHERE id = NEW.product_id;
        END IF;
    END IF;
    
    RETURN COALESCE(NEW, OLD);
END;
$$;

-- Function: Notify customers when order status changes
CREATE OR REPLACE FUNCTION public.notify_order_status_change() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
  customer_user_id UUID;
BEGIN
  -- Only notify on status changes
  IF OLD.status IS DISTINCT FROM NEW.status THEN
    -- Get customer user_id
    SELECT c.user_id INTO customer_user_id
    FROM customer c
    WHERE c.id = NEW.customer_id;
    
    -- Create notification
    INSERT INTO notification (
      user_id,
      notification_text,
      notification_type,
      category,
      link,
      priority,
      data
    ) VALUES (
      customer_user_id,
      'Your order #' || NEW.id || ' status has been updated to: ' || NEW.status,
      'order_status_update',
      'orders',
      '/account/orders',
      'normal',
      jsonb_build_object(
        'order_id', NEW.id,
        'old_status', OLD.status,
        'new_status', NEW.status
      )
    );
  END IF;
  
  RETURN NEW;
END;
$$;

-- Function: Notify customers when Q&A is answered
CREATE OR REPLACE FUNCTION public.notify_qa_answered() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
  customer_user_id UUID;
  question_text TEXT;
  product_name TEXT;
BEGIN
  -- Get customer user_id and question details
  SELECT c.user_id, pqa.question_text, p.name
  INTO customer_user_id, question_text, product_name
  FROM product_qa pqa
  JOIN customer c ON pqa.customer_id = c.id
  JOIN product p ON pqa.product_id = p.id
  WHERE pqa.id = NEW.question_id;

  -- Create notification for customer
  INSERT INTO notification (
    user_id,
    notification_text,
    notification_type,
    category,
    link,
    priority,
    data
  ) VALUES (
    customer_user_id,
    'Your question about "' || product_name || '" has been answered.',
    'qa_answered',
    'support',
    '/product/' || (SELECT product_id FROM product_qa WHERE id = NEW.question_id),
    'normal',
    jsonb_build_object(
      'question_id', NEW.question_id,
      'answer_id', NEW.id,
      'product_name', product_name,
      'is_published', NEW.is_published
    )
  );

  -- Send message if requested
  IF NEW.send_to_customer = TRUE THEN
    INSERT INTO message (
      sender_id,
      receiver_id,
      message_text,
      subject,
      message_type,
      is_system_message
    ) VALUES (
      (SELECT user_id FROM admin_users WHERE admin_id = NEW.admin_id),
      customer_user_id,
      'Your question: "' || LEFT(question_text, 100) || '..." has been answered: ' || NEW.answer_text,
      'Answer to your product question',
      'text',
      TRUE
    );
  END IF;

  -- Update question status
  UPDATE product_qa
  SET status = CASE
    WHEN NEW.is_published THEN 'published'
    ELSE 'answered'
  END,
  updated_at = CURRENT_TIMESTAMP
  WHERE id = NEW.question_id;

  RETURN NEW;
END;
$$;

-- Function: Validate rating eligibility
CREATE OR REPLACE FUNCTION public.validate_rating_eligibility() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
  -- Check if the order exists and is delivered
  -- Handle both direct products and products from builds
  IF NOT EXISTS (
    -- Check for direct product purchase
    SELECT 1 
    FROM "order" o
    JOIN order_item oi ON o.id = oi.order_id
    JOIN customer c ON o.customer_id = c.id
    WHERE o.id = NEW.order_id 
      AND oi.id = NEW.order_item_id
      AND c.user_id = NEW.user_id
      AND oi.product_id = NEW.product_id
      AND o.status = 'delivered'
    
    UNION
    
    -- Check for product from build purchase
    SELECT 1
    FROM "order" o
    JOIN order_item oi ON o.id = oi.order_id
    JOIN customer c ON o.customer_id = c.id
    JOIN build b ON oi.build_id = b.id
    JOIN build_product bp ON b.id = bp.build_id
    WHERE o.id = NEW.order_id 
      AND oi.id = NEW.order_item_id
      AND c.user_id = NEW.user_id
      AND bp.product_id = NEW.product_id
      AND o.status = 'delivered'
  ) THEN
    RAISE EXCEPTION 'Can only rate products from delivered orders that you have purchased';
  END IF;
  
  RETURN NEW;
END;
$$;

-- Function: Update conversation last message timestamp
CREATE OR REPLACE FUNCTION public.update_conversation_last_message() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
  UPDATE conversation 
  SET last_message_at = NEW.sent_at, updated_at = CURRENT_TIMESTAMP
  WHERE id = NEW.conversation_id;
  RETURN NEW;
END;
$$;

-- Function: Generic updated_at timestamp updater
CREATE OR REPLACE FUNCTION public.update_updated_at_column() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
  NEW.updated_at = CURRENT_TIMESTAMP;
  RETURN NEW;
END;
$$;

-- Function: Update admin_users updated_at
CREATE OR REPLACE FUNCTION public.update_admin_users_updated_at() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
  NEW.updated_at = CURRENT_TIMESTAMP;
  RETURN NEW;
END;
$$;

-- Function: Update access_levels updated_at
CREATE OR REPLACE FUNCTION public.update_access_levels_updated_at() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
  NEW.updated_at = CURRENT_TIMESTAMP;
  RETURN NEW;
END;
$$;

-- Function: Update signup requests updated_at
CREATE OR REPLACE FUNCTION public.update_signup_requests_updated_at() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
  NEW.updated_at = CURRENT_TIMESTAMP;
  RETURN NEW;
END;
$$;

-- Function: Sync all product availability with stock
CREATE OR REPLACE FUNCTION public.sync_all_product_availability() RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
    -- Set availability to false for products with 0 stock
    UPDATE product 
    SET availability = false 
    WHERE id IN (
        SELECT product_id 
        FROM product_attribute 
        WHERE stock = 0
    );
    
    -- Set availability to true for products with positive stock
    UPDATE product 
    SET availability = true 
    WHERE id IN (
        SELECT product_id 
        FROM product_attribute 
        WHERE stock > 0
    );
    
    RAISE NOTICE 'Product availability synced with stock levels';
END;
$$;

-- =====================================================
-- CREATE TRIGGERS
-- =====================================================

-- Stock management triggers
CREATE TRIGGER cart_stock_check_trigger 
    BEFORE INSERT OR UPDATE OF quantity ON public.cart_item 
    FOR EACH ROW EXECUTE FUNCTION public.check_cart_stock();

CREATE TRIGGER order_item_stock_check_trigger 
    BEFORE INSERT OR UPDATE OF quantity ON public.order_item 
    FOR EACH ROW EXECUTE FUNCTION public.check_order_stock();

CREATE TRIGGER order_stock_trigger 
    AFTER INSERT OR UPDATE OF status ON public."order" 
    FOR EACH ROW EXECUTE FUNCTION public.handle_order_stock();

CREATE TRIGGER stock_availability_trigger 
    AFTER INSERT OR UPDATE OF stock ON public.product_attribute 
    FOR EACH ROW EXECUTE FUNCTION public.update_product_availability();

-- Notification triggers
CREATE TRIGGER trg_notify_order_status_change 
    AFTER UPDATE ON public."order" 
    FOR EACH ROW EXECUTE FUNCTION public.notify_order_status_change();

CREATE TRIGGER trg_notify_qa_answered 
    AFTER INSERT ON public.qa_answer 
    FOR EACH ROW EXECUTE FUNCTION public.notify_qa_answered();

-- Timestamp update triggers
CREATE TRIGGER trg_access_levels_updated_at 
    BEFORE UPDATE ON public.access_levels 
    FOR EACH ROW EXECUTE FUNCTION public.update_access_levels_updated_at();

CREATE TRIGGER trg_admin_updated_at 
    BEFORE UPDATE ON public.admin 
    FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER trg_admin_users_updated_at 
    BEFORE UPDATE ON public.admin_users 
    FOR EACH ROW EXECUTE FUNCTION public.update_admin_users_updated_at();

CREATE TRIGGER trg_build_updated_at 
    BEFORE UPDATE ON public.build 
    FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER trg_cart_updated_at 
    BEFORE UPDATE ON public.cart 
    FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER trg_conversation_updated_at 
    BEFORE UPDATE ON public.conversation 
    FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER trg_customer_updated_at 
    BEFORE UPDATE ON public.customer 
    FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER trg_general_user_updated_at 
    BEFORE UPDATE ON public.general_user 
    FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER trg_order_updated_at 
    BEFORE UPDATE ON public."order" 
    FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER trg_product_attribute_updated_at 
    BEFORE UPDATE ON public.product_attribute 
    FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER trg_product_category_updated_at 
    BEFORE UPDATE ON public.product_category 
    FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER trg_product_qa_updated_at 
    BEFORE UPDATE ON public.product_qa 
    FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER trg_product_updated_at 
    BEFORE UPDATE ON public.product 
    FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER trg_promo_updated_at 
    BEFORE UPDATE ON public.promo 
    FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER trg_qa_answer_updated_at 
    BEFORE UPDATE ON public.qa_answer 
    FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER trg_ratings_updated_at 
    BEFORE UPDATE ON public.ratings 
    FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER trg_shipping_address_updated_at 
    BEFORE UPDATE ON public.shipping_address 
    FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER trg_signup_requests_updated_at 
    BEFORE UPDATE ON public.admin_signup_requests 
    FOR EACH ROW EXECUTE FUNCTION public.update_signup_requests_updated_at();

CREATE TRIGGER trg_template_updated_at 
    BEFORE UPDATE ON public.template 
    FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

-- Messaging triggers
CREATE TRIGGER trg_update_conversation_last_message 
    AFTER INSERT ON public.message 
    FOR EACH ROW EXECUTE FUNCTION public.update_conversation_last_message();

-- Rating validation trigger
CREATE TRIGGER trg_validate_rating_eligibility 
    BEFORE INSERT OR UPDATE ON public.ratings 
    FOR EACH ROW EXECUTE FUNCTION public.validate_rating_eligibility();

-- =====================================================
-- VIEWS
-- =====================================================

-- Active notifications view
CREATE VIEW public.active_notifications AS
 SELECT n.id,
    n.user_id,
    n.notification_text,
    n.seen_status,
    n.created_at,
    n.notification_type,
    n.category,
    n.action_url,
    n.expires_at,
    n.priority,
    n.data,
    n.link,
    gu.username,
    gu.full_name
   FROM (public.notification n
     JOIN public.general_user gu ON ((n.user_id = gu.id)))
  WHERE (((n.expires_at IS NULL) OR (n.expires_at > CURRENT_TIMESTAMP)) AND (n.seen_status = false))
  ORDER BY n.priority DESC, n.created_at DESC;

-- Admin Q&A management view
CREATE VIEW public.admin_qa_management AS
 SELECT pqa.id AS question_id,
    pqa.product_id,
    p.name AS product_name,
    pqa.customer_id,
    gu.full_name AS customer_name,
    gu.username AS customer_username,
    pqa.question_text,
    pqa.priority,
    pqa.status,
    pqa.category,
    pqa.time_asked,
    pqa.updated_at,
    qaa.id AS answer_id,
    qaa.answer_text,
    qaa.is_published,
    qaa.send_to_customer,
    qaa.time_answered,
    admin_gu.full_name AS answered_by
   FROM ((((((public.product_qa pqa
     JOIN public.product p ON ((pqa.product_id = p.id)))
     JOIN public.customer c ON ((pqa.customer_id = c.id)))
     JOIN public.general_user gu ON ((c.user_id = gu.id)))
     LEFT JOIN public.qa_answer qaa ON ((pqa.id = qaa.question_id)))
     LEFT JOIN public.admin a ON ((qaa.admin_id = a.id)))
     LEFT JOIN public.general_user admin_gu ON ((a.user_id = admin_gu.id)))
  ORDER BY pqa.priority DESC, pqa.time_asked DESC;

-- User ratable products view
CREATE VIEW public.user_ratable_products AS
WITH delivered_orders AS (
    SELECT DISTINCT 
        c.user_id,
        o.id as order_id,
        o.order_date,
        o.status as order_status,
        oi.id as order_item_id,
        oi.product_id,
        oi.build_id,
        oi.quantity,
        oi.unit_price
    FROM "order" o
    JOIN customer c ON o.customer_id = c.id
    JOIN order_item oi ON o.id = oi.order_id
    WHERE o.status = 'delivered'
),
direct_products AS (
    SELECT 
        do.user_id,
        do.order_id,
        do.order_date,
        do.order_status,
        do.order_item_id,
        do.product_id,
        p.name as product_name,
        p.image_url,
        do.quantity,
        do.unit_price,
        'product' as item_type
    FROM delivered_orders do
    JOIN product p ON do.product_id = p.id
    WHERE do.product_id IS NOT NULL
),
build_products AS (
    SELECT 
        do.user_id,
        do.order_id,
        do.order_date,
        do.order_status,
        do.order_item_id,
        bp.product_id,
        p.name as product_name,
        p.image_url,
        bp.quantity,
        do.unit_price,
        'build' as item_type
    FROM delivered_orders do
    JOIN build b ON do.build_id = b.id
    JOIN build_product bp ON b.id = bp.build_id
    JOIN product p ON bp.product_id = p.id
    WHERE do.build_id IS NOT NULL
),
all_ratable AS (
    SELECT * FROM direct_products
    UNION ALL
    SELECT * FROM build_products
)
SELECT DISTINCT
    ar.user_id,
    ar.product_id,
    ar.product_name,
    ar.image_url,
    ar.order_item_id,
    ar.order_id,
    ar.order_date,
    ar.order_status,
    ar.item_type
FROM all_ratable ar
LEFT JOIN ratings r ON (ar.user_id = r.user_id AND ar.product_id = r.product_id)
WHERE r.id IS NULL;

-- =====================================================
-- PERFORMANCE INDEXES
-- =====================================================

-- User and authentication indexes
CREATE INDEX idx_general_user_username ON public.general_user USING btree (username);
CREATE INDEX idx_general_user_email ON public.general_user USING btree (email);
CREATE INDEX idx_customer_user_id ON public.customer USING btree (user_id);

-- Admin system indexes
CREATE INDEX idx_access_levels_name ON public.access_levels USING btree (access_name);
CREATE INDEX idx_admin_clearance_level ON public.admin_users USING btree (clearance_level);
CREATE INDEX idx_admin_logs_created_at ON public.admin_logs USING btree (created_at);
CREATE INDEX idx_admin_user_id ON public.admin USING btree (user_id);
CREATE INDEX idx_admin_users_clearance_level ON public.admin_users USING btree (clearance_level);
CREATE INDEX idx_admin_users_user_id ON public.admin_users USING btree (user_id);
CREATE INDEX idx_signup_requests_status ON public.admin_signup_requests USING btree (status);

-- Product catalog indexes
CREATE INDEX idx_product_availability ON public.product USING btree (availability);
CREATE INDEX idx_product_category_id ON public.product USING btree (category_id);
CREATE INDEX idx_product_specs_gin ON public.product USING gin (specs);
CREATE INDEX idx_product_attribute_product_id ON public.product_attribute USING btree (product_id);
CREATE INDEX idx_product_attribute_stock ON public.product_attribute USING btree (stock);

-- Cart and order indexes
CREATE INDEX idx_cart_customer_id ON public.cart USING btree (customer_id);
CREATE INDEX idx_cart_item_cart_id ON public.cart_item USING btree (cart_id);
CREATE INDEX idx_cart_item_product_id ON public.cart_item USING btree (product_id);
CREATE INDEX idx_order_customer_id ON public."order" USING btree (customer_id);
CREATE INDEX idx_order_item_build_id ON public.order_item USING btree (build_id);
CREATE INDEX idx_order_item_order_id ON public.order_item USING btree (order_id);
CREATE INDEX idx_order_item_product_id ON public.order_item USING btree (product_id);
CREATE INDEX idx_order_promo_id ON public."order" USING btree (promo_id);
CREATE INDEX idx_shipping_address_customer_id ON public.shipping_address USING btree (customer_id);

-- Build system indexes
CREATE INDEX idx_build_customer_id ON public.build USING btree (customer_id);
CREATE INDEX idx_build_product_build_id ON public.build_product USING btree (build_id);
CREATE INDEX idx_build_product_product_id ON public.build_product USING btree (product_id);
CREATE INDEX idx_build_template_id ON public.build USING btree (template_id);
CREATE INDEX idx_template_product_product_id ON public.template_product USING btree (product_id);
CREATE INDEX idx_template_product_template_id ON public.template_product USING btree (template_id);
CREATE INDEX idx_compatibility_rules_active ON public.compatibility_rules USING btree (is_active);
CREATE INDEX idx_compatibility_rules_category1 ON public.compatibility_rules USING btree (category1_id);
CREATE INDEX idx_compatibility_rules_category2 ON public.compatibility_rules USING btree (category2_id);

-- Review and rating indexes
CREATE INDEX idx_ratings_created_at ON public.ratings USING btree (created_at);
CREATE INDEX idx_ratings_order_id ON public.ratings USING btree (order_id);
CREATE INDEX idx_ratings_product_id ON public.ratings USING btree (product_id);
CREATE INDEX idx_ratings_rating ON public.ratings USING btree (rating);
CREATE INDEX idx_ratings_user_id ON public.ratings USING btree (user_id);
CREATE INDEX idx_review_customer_id ON public.review USING btree (customer_id);
CREATE INDEX idx_review_product_id ON public.review USING btree (product_id);

-- Q&A system indexes
CREATE INDEX idx_product_qa_customer_id ON public.product_qa USING btree (customer_id);
CREATE INDEX idx_product_qa_priority ON public.product_qa USING btree (priority);
CREATE INDEX idx_product_qa_product_id ON public.product_qa USING btree (product_id);
CREATE INDEX idx_product_qa_status ON public.product_qa USING btree (status);
CREATE INDEX idx_qa_answer_admin_id ON public.qa_answer USING btree (admin_id);
CREATE INDEX idx_qa_answer_published ON public.qa_answer USING btree (is_published);
CREATE INDEX idx_qa_answer_question_id ON public.qa_answer USING btree (question_id);

-- Messaging and communication indexes
CREATE INDEX idx_conversation_assigned_to ON public.conversation USING btree (assigned_to);
CREATE INDEX idx_conversation_created_by ON public.conversation USING btree (created_by);
CREATE INDEX idx_conversation_last_message ON public.conversation USING btree (last_message_at);
CREATE INDEX idx_conversation_participant_conversation ON public.conversation_participant USING btree (conversation_id);
CREATE INDEX idx_conversation_participant_user ON public.conversation_participant USING btree (user_id);
CREATE INDEX idx_conversation_status ON public.conversation USING btree (status);
CREATE INDEX idx_conversation_type ON public.conversation USING btree (type);
CREATE INDEX idx_message_conversation_id ON public.message USING btree (conversation_id);
CREATE INDEX idx_message_priority ON public.message USING btree (priority);
CREATE INDEX idx_message_receiver_id ON public.message USING btree (receiver_id);
CREATE INDEX idx_message_sender_id ON public.message USING btree (sender_id);
CREATE INDEX idx_message_status ON public.message USING btree (message_status);

-- Notification indexes
CREATE INDEX idx_notification_category ON public.notification USING btree (category);
CREATE INDEX idx_notification_expires_at ON public.notification USING btree (expires_at);
CREATE INDEX idx_notification_priority ON public.notification USING btree (priority);
CREATE INDEX idx_notification_user_id ON public.notification USING btree (user_id);
CREATE INDEX idx_notifications_is_read ON public.admin_notifications USING btree (is_read);

-- =====================================================
-- INITIAL DATA
-- =====================================================

-- Insert access levels for admin system
INSERT INTO public.access_levels (access_level, access_name, description) VALUES
(0, 'General Manager', 'Highest level of access - can manage all aspects of the system'),
(2, 'Inventory Manager', 'Can manage inventory and stock levels'),
(3, 'Product Manager', 'Manages product catalog, pricing, and product-related operations'),
(4, 'Order Manager', 'Can manage orders and delivery status'),
(5, 'Promotion Manager', 'Can manage promotions and discounts'),
(6, 'Analytics Specialist', 'Can view and analyze system data')
ON CONFLICT (access_level) DO NOTHING;

-- =====================================================
-- POST-SETUP INSTRUCTIONS
-- =====================================================

-- After running this schema:
-- 1. Import product categories and products
-- 2. Create first admin user through signup process
-- 3. Configure email settings for notifications
-- 4. Set up file upload directories for product images
-- 5. Configure payment gateway settings
-- 6. Set up backup and monitoring

-- =====================================================
-- LOYALTY POINTS AND VOUCHERS SYSTEM (NEW)
-- Added: 2025-07-27 - Customer Loyalty Program
-- =====================================================

-- Customer Points Balance Table
-- Tracks the current points balance and lifetime statistics for each customer
CREATE TABLE public.customer_points (
    id SERIAL PRIMARY KEY,
    customer_id uuid NOT NULL,
    points_balance integer DEFAULT 0 NOT NULL,
    total_earned integer DEFAULT 0 NOT NULL,
    total_redeemed integer DEFAULT 0 NOT NULL,
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP NOT NULL,
    updated_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP NOT NULL,
    CONSTRAINT customer_points_customer_id_unique UNIQUE (customer_id),
    CONSTRAINT customer_points_balance_check CHECK ((points_balance >= 0)),
    CONSTRAINT customer_points_customer_id_fkey FOREIGN KEY (customer_id) REFERENCES public.customer(id) ON DELETE CASCADE
);

-- Points Transaction History Table
-- Records all points transactions (earned, redeemed, expired, bonus)
CREATE TABLE public.points_transaction (
    id SERIAL PRIMARY KEY,
    customer_id uuid NOT NULL,
    transaction_type character varying(20) NOT NULL,
    points integer NOT NULL,
    order_id integer,
    voucher_id integer,
    description text,
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP NOT NULL,
    CONSTRAINT points_transaction_type_check CHECK (((transaction_type)::text = ANY ((ARRAY['earned'::character varying, 'redeemed'::character varying, 'expired'::character varying, 'bonus'::character varying])::text[]))),
    CONSTRAINT points_transaction_customer_id_fkey FOREIGN KEY (customer_id) REFERENCES public.customer(id) ON DELETE CASCADE,
    CONSTRAINT points_transaction_order_id_fkey FOREIGN KEY (order_id) REFERENCES public."order"(id) ON DELETE SET NULL
);

-- Vouchers/Coupons Table
-- Manages discount coupons that customers can redeem with points
CREATE TABLE public.vouchers (
    id SERIAL PRIMARY KEY,
    customer_id uuid NOT NULL,
    code character varying(50) NOT NULL UNIQUE,
    type character varying(20) DEFAULT 'discount'::character varying NOT NULL,
    value numeric(10,2) NOT NULL,
    discount_type character varying(20) DEFAULT 'percentage'::character varying NOT NULL,
    min_order_amount numeric(10,2) DEFAULT 0,
    max_discount_amount numeric(10,2),
    is_redeemed boolean DEFAULT false NOT NULL,
    redeemed_at timestamp without time zone,
    order_id integer,
    points_used integer,
    expires_at timestamp without time zone,
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP NOT NULL,
    CONSTRAINT vouchers_type_check CHECK (((type)::text = ANY ((ARRAY['discount'::character varying, 'free_shipping'::character varying, 'cashback'::character varying])::text[]))),
    CONSTRAINT vouchers_discount_type_check CHECK (((discount_type)::text = ANY ((ARRAY['percentage'::character varying, 'fixed_amount'::character varying])::text[]))),
    CONSTRAINT vouchers_customer_id_fkey FOREIGN KEY (customer_id) REFERENCES public.customer(id) ON DELETE CASCADE,
    CONSTRAINT vouchers_order_id_fkey FOREIGN KEY (order_id) REFERENCES public."order"(id) ON DELETE SET NULL
);

-- Add foreign key for voucher_id in points_transaction (requires vouchers table to exist first)
ALTER TABLE public.points_transaction ADD CONSTRAINT points_transaction_voucher_id_fkey FOREIGN KEY (voucher_id) REFERENCES public.vouchers(id) ON DELETE SET NULL;

-- =====================================================
-- LOYALTY SYSTEM INDEXES
-- =====================================================

-- Points and Vouchers System Indexes for Performance
CREATE INDEX idx_customer_points_customer_id ON public.customer_points USING btree (customer_id);
CREATE INDEX idx_points_transaction_customer_id ON public.points_transaction USING btree (customer_id);
CREATE INDEX idx_points_transaction_type ON public.points_transaction USING btree (transaction_type);
CREATE INDEX idx_vouchers_customer_id ON public.vouchers USING btree (customer_id);
CREATE INDEX idx_vouchers_code ON public.vouchers USING btree (code);
CREATE INDEX idx_vouchers_is_redeemed ON public.vouchers USING btree (is_redeemed);
CREATE INDEX idx_vouchers_expires_at ON public.vouchers USING btree (expires_at);

-- =====================================================
-- LOYALTY SYSTEM FUNCTIONS
-- =====================================================

-- Function: Award Points for Completed Orders
-- Automatically awards 1 point per dollar spent when order status changes to 'delivered'
CREATE OR REPLACE FUNCTION public.award_points_for_order() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
    customer_uuid UUID;
    points_to_award INTEGER;
BEGIN
    -- Get customer UUID from the order
    SELECT c.id INTO customer_uuid
    FROM customer c
    WHERE c.user_id = NEW.customer_id;

    IF customer_uuid IS NOT NULL THEN
        -- Calculate points (1 point per dollar spent)
        points_to_award := FLOOR(NEW.total_amount);

        -- Insert or update customer points
        INSERT INTO customer_points (customer_id, points_balance, total_earned)
        VALUES (customer_uuid, points_to_award, points_to_award)
        ON CONFLICT (customer_id) 
        DO UPDATE SET 
            points_balance = customer_points.points_balance + points_to_award,
            total_earned = customer_points.total_earned + points_to_award,
            updated_at = CURRENT_TIMESTAMP;

        -- Record the transaction
        INSERT INTO points_transaction (
            customer_id, 
            transaction_type, 
            points, 
            order_id, 
            description
        ) VALUES (
            customer_uuid,
            'earned',
            points_to_award,
            NEW.id,
            'Points earned from order #' || NEW.id || ' - $' || NEW.total_amount
        );

        -- Create notification for points earned
        INSERT INTO notification (
            user_id,
            notification_text,
            notification_type,
            category,
            link,
            priority,
            data
        ) VALUES (
            NEW.customer_id,
            ' You earned ' || points_to_award || ' points from your recent order! Use them to get discount coupons.',
            'points_earned',
            'rewards',
            '/account/vouchers',
            'normal',
            jsonb_build_object(
                'points_earned', points_to_award,
                'order_id', NEW.id,
                'total_amount', NEW.total_amount,
                'points_rate', '1 point per $1 spent'
            )
        );
    END IF;

    RETURN NEW;
END;
$$;

-- Function: Handle Voucher Redemption Notifications
-- Creates notifications when vouchers are successfully applied to orders
CREATE OR REPLACE FUNCTION public.redeem_voucher() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    -- When a voucher is marked as redeemed, create a notification
    IF NEW.is_redeemed = true AND OLD.is_redeemed = false THEN
        INSERT INTO notification (
            user_id,
            notification_text,
            notification_type,
            category,
            link,
            priority,
            data
        ) VALUES (
            (SELECT c.user_id FROM customer c WHERE c.id = NEW.customer_id),
            ' Voucher ' || NEW.code || ' has been successfully applied to your order!',
            'voucher_redeemed',
            'orders',
            '/account/orders',
            'normal',
            jsonb_build_object(
                'voucher_code', NEW.code,
                'voucher_value', NEW.value,
                'discount_type', NEW.discount_type,
                'order_id', NEW.order_id
            )
        );
    END IF;

    RETURN NEW;
END;
$$;

-- Function: Expire Old Vouchers
-- Utility function to mark expired vouchers (can be called by cron job)
CREATE OR REPLACE FUNCTION public.expire_old_vouchers() RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
    expired_count INTEGER;
BEGIN
    -- Mark expired vouchers
    UPDATE vouchers 
    SET is_redeemed = true, 
        redeemed_at = CURRENT_TIMESTAMP
    WHERE expires_at < CURRENT_TIMESTAMP 
      AND is_redeemed = false;
    
    GET DIAGNOSTICS expired_count = ROW_COUNT;
    
    RETURN expired_count;
END;
$$;

-- =====================================================
-- LOYALTY SYSTEM TRIGGERS
-- =====================================================

-- Trigger: Automatic Points Award
-- Fires when order status changes to 'delivered'
CREATE TRIGGER trg_award_points_for_order 
    AFTER UPDATE OF status ON public."order"
    FOR EACH ROW 
    WHEN (NEW.status = 'delivered' AND OLD.status != 'delivered')
    EXECUTE FUNCTION public.award_points_for_order();

-- Trigger: Voucher Redemption Notification
-- Fires when voucher is marked as redeemed
CREATE TRIGGER trg_redeem_voucher 
    AFTER UPDATE ON public.vouchers
    FOR EACH ROW 
    EXECUTE FUNCTION public.redeem_voucher();

-- =====================================================
-- LOYALTY SYSTEM VIEWS
-- =====================================================

-- View: Customer Points Summary
-- Comprehensive view of customer points status
CREATE OR REPLACE VIEW customer_points_summary AS
SELECT 
    c.id as customer_id,
    gu.username,
    gu.email,
    gu.full_name,
    cp.points_balance,
    cp.total_earned,
    cp.total_redeemed,
    (cp.total_earned - cp.total_redeemed) as lifetime_points_difference,
    cp.created_at as points_account_created,
    cp.updated_at as last_points_activity
FROM customer c
JOIN general_user gu ON c.user_id = gu.id
LEFT JOIN customer_points cp ON c.id = cp.customer_id;

-- View: Voucher Statistics
-- Monthly statistics for voucher creation and redemption
CREATE OR REPLACE VIEW voucher_stats AS
SELECT 
    DATE_TRUNC('month', created_at) as month,
    COUNT(*) as total_vouchers_created,
    COUNT(*) FILTER (WHERE is_redeemed = true) as vouchers_redeemed,
    COUNT(*) FILTER (WHERE expires_at < CURRENT_TIMESTAMP AND is_redeemed = false) as vouchers_expired,
    SUM(value) FILTER (WHERE is_redeemed = true) as total_discount_given
FROM vouchers
GROUP BY DATE_TRUNC('month', created_at)
ORDER BY month DESC;

-- =====================================================
-- LOYALTY SYSTEM BUSINESS RULES
-- =====================================================

/*
LOYALTY POINTS SYSTEM RULES:
1. Points Earning: 1 point per $1 spent on completed orders (when status = 'delivered')
2. Points Redemption: Minimum 100 points to redeem (multiples of 100)
3. Voucher Value: Each 100 points = 1 coupon worth 10% discount
4. Voucher Expiry: Coupons expire after 365 days from creation
5. Maximum Discount: 50% of order total (configurable in backend)
6. Minimum Order: $10 to use vouchers

VOUCHER CODES FORMAT:
- Pattern: TECH-XXXXXX-XXXX
- X = Random alphanumeric characters
- Example: TECH-AB12CD-3456

POINT TRANSACTION TYPES:
- 'earned': Points from completed orders
- 'redeemed': Points used to generate vouchers
- 'expired': Points that expired (if implemented)
- 'bonus': Admin bonus points or promotional points

NOTIFICATION CATEGORIES FOR LOYALTY SYSTEM:
- 'rewards': Points earned, vouchers created
- 'orders': Order updates, voucher usage
- 'promotions': Special offers, bonus points

API ENDPOINTS IMPLEMENTED:
- GET /api/account/vouchers - Get customer points and vouchers
- POST /api/account/redeem-points - Redeem points for vouchers
- GET /api/account/points-history - Get points transaction history
*/

-- =====================================================
-- END OF SCHEMA (INCLUDING LOYALTY SYSTEM)
-- =====================================================
